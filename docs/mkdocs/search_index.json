{
    "docs": [
        {
            "location": "/", 
            "text": "Immview 3\n\n\n...is a library to create \nDomain\ns - \nnon-visual components\n -\nsimilar to flux stores, exposing their \nstate\n (through \nAtom\ns) or emitting \nsignals\n\n(through \nObservable\ns) and having specific to their concerns \nactions\n.\nTheir primary role is to encapsulate a concern\nand to be the only thing exported from a javascript module or modules\nthat deal with the concern.\n\n\nIt completely replaces any flux implementation or Redux, although surely could be integrated with one easily.\n\n\nAll \nDomain\ns must be provided with a single stream of values\n(\nAtom\n or \nObservable\n class instance),\nbut not all \nObservable\ns and \nAtom\ns must be attached to a \nDomain\n -\nyou can perform many transformations on a source\nbefore it is exposed through a \nDomain\n.\nThese transformations are done with operators -\nfunctions that exist on these classes prototypes.\n\n\nQuick intro\n\n\nimport { Atom, Domain } from 'immview'\n\nconst toDoList$ = new Atom([])\n\nconst toDoActions = {\n  add(label) {\n    toDoList$.next(\n      todos =\n [\n        { label, done: false },\n        ...todos\n      ]\n    )\n  },\n\n  check(index) {\n    toDoList$.next(\n      todos =\n todos.map(\n          (todo, i) =\n (\n              i === index\n                ? { label: todo.label, done: true }\n                : todo\n          )\n      )\n    )\n  },\n\n  remove(index) {\n    toDoList$.next(\n      todos =\n todos.filter((_, i) =\n i !== index)\n    )\n  }\n}\n\nconst ToDo$ = Domain.create(\n  toDoList$,\n  toDoActions\n)\n\nToDo$.subscribe(v =\n console.log(JSON.stringify(v)))\n// console: []\n\nToDo$.add('Eat a pizza')\n// console: [{ label: \nEat a pizza\n, done: false }]\n\nToDo$.check(0)\n// console: [{ label: \nEat a pizza\n, done: true }]\n\n\n\n\nLive preview\n\n\n\n\nsee above live on https://runkit.com/arturkulig/immview-todo-example\n\n\n\n\nInstallation\n\n\nGet it on \nnpm\n\n\nnpm i -S immview\n\n\n\n\nor with \nyarn\n\n\nyarn add immview\n\n\n\n\nReact\n\n\nIf you are using React to create presentation layer of your app you should check \nimmview-react-connect", 
            "title": "Start"
        }, 
        {
            "location": "/#immview-3", 
            "text": "...is a library to create  Domain s -  non-visual components  -\nsimilar to flux stores, exposing their  state  (through  Atom s) or emitting  signals \n(through  Observable s) and having specific to their concerns  actions .\nTheir primary role is to encapsulate a concern\nand to be the only thing exported from a javascript module or modules\nthat deal with the concern.  It completely replaces any flux implementation or Redux, although surely could be integrated with one easily.  All  Domain s must be provided with a single stream of values\n( Atom  or  Observable  class instance),\nbut not all  Observable s and  Atom s must be attached to a  Domain  -\nyou can perform many transformations on a source\nbefore it is exposed through a  Domain .\nThese transformations are done with operators -\nfunctions that exist on these classes prototypes.", 
            "title": "Immview 3"
        }, 
        {
            "location": "/#quick-intro", 
            "text": "import { Atom, Domain } from 'immview'\n\nconst toDoList$ = new Atom([])\n\nconst toDoActions = {\n  add(label) {\n    toDoList$.next(\n      todos =  [\n        { label, done: false },\n        ...todos\n      ]\n    )\n  },\n\n  check(index) {\n    toDoList$.next(\n      todos =  todos.map(\n          (todo, i) =  (\n              i === index\n                ? { label: todo.label, done: true }\n                : todo\n          )\n      )\n    )\n  },\n\n  remove(index) {\n    toDoList$.next(\n      todos =  todos.filter((_, i) =  i !== index)\n    )\n  }\n}\n\nconst ToDo$ = Domain.create(\n  toDoList$,\n  toDoActions\n)\n\nToDo$.subscribe(v =  console.log(JSON.stringify(v)))\n// console: []\n\nToDo$.add('Eat a pizza')\n// console: [{ label:  Eat a pizza , done: false }]\n\nToDo$.check(0)\n// console: [{ label:  Eat a pizza , done: true }]", 
            "title": "Quick intro"
        }, 
        {
            "location": "/#live-preview", 
            "text": "see above live on https://runkit.com/arturkulig/immview-todo-example", 
            "title": "Live preview"
        }, 
        {
            "location": "/#installation", 
            "text": "Get it on  npm  npm i -S immview  or with  yarn  yarn add immview", 
            "title": "Installation"
        }, 
        {
            "location": "/#react", 
            "text": "If you are using React to create presentation layer of your app you should check  immview-react-connect", 
            "title": "React"
        }, 
        {
            "location": "/Observable/", 
            "text": "class \nObservable\nT\n\n\nnew (subscriber: (observer: {next: (value: T) =\n void, error: (err: Error) =\n void, complete: () =\n void}) =\n void | () =\n void)\n\n\nConstruct with \nsubscriber\n function that receives \nobserver\n object. \nObserver\n is for pushing values, errors and completion signal.\n\n\nSubscriber\n function may return function that should be called if \nObservable\n receives \ncomplete\n signal or is cancelled.\n\n\n\n\nstatic \nof\n\n\n(...args: T[]): Observable\nT\n;\n\n\nFunction to create an \nObservable\n that immediately pushes values given as arguments.\n\n\n\n\nImportant\n\n\nStream is immediately completed after all values are pushed.\n\n\n\n\nIf you wish to create a stream and kickstart it with a value(s), use \nstartWith\n.\n\n\n\n\nstatic \nfrom\n\n\n(values: T[]): Observable\nT\n;\n\n\nFunction to create an \nObservable\n that immediately pushes values given as an array of values.\n\n\n\n\nImportant\n\n\nStream is immediately completed after all values are pushed.\n\n\n\n\nIf you wish to create a stream and kickstart it with a value(s), use \nstartWith\n.\n\n\n\n\nstatic \nfromPromise\n\n\n(values: Promise\nT\n): Observable\nT\n\n\nFunction to create an \nObservable\n that pushes a value\nrevealed with provided \nPromise\n and then completes\nas no more values to get from it.\n\n\nSubscribable interface\n\n\n\n\nsubscribe\n\n\n({\n\n\nstart: (sub: Subscription) =\n void,\n\n\nnext: (value: T) =\n void,\n\n\nerror: (err: Error) =\n void,\n\n\ncomplete: () =\n void\n\n\n} ) =\n { unsubscribe(): void }\n\n\n(\n\n\nonNext?: (value: T) =\n void,\n\n\nonError?: (err: Error) =\n void,\n\n\nonCompletion?: () =\n void\n\n\n) =\n { unsubscribe(): void }\n\n\nRegisters a function called every time when the Observable changes value that it holds, error is pushed or Observable is complete.\n\n\nReturns a function to unregister the subscription.\n\n\n\n\ntoPromise\n\n\n() =\n Promise\nT\n\n\nReturns next \nvalue\n that's going to be pushed through the \nObservable\n instance.\n\n\n// Example\nconst source = new Observable()\nsetTimeout(() =\n source.next(1), 100)\nconst value = await source.toPromise()\n\n\n\n\nPromise interface\n\n\nObservable\ns are also implementing interface of a \nPromise\n,\n so it actually is possible to deref as if \nObservable\n was a \nPromise\n\n and use it both with \n.then\n and \nasync..await\n\n\nwith \nawait\n\n\n(async () =\n {\n    console.log(\n        await new Observable(observer =\n { observer.next(1) })\n    )\n    // logs: 1\n})()\n\n\n\n\nthen\n\n\nU\n(onsuccess?: (value: T) =\n Promise\nU\n | U, onrejection?: (reason: any) =\n any): Promise\nU\n\n\n    new Observable(\n        observer =\n { observer.next(1) }).then(_ =\n console.log(_)\n    )\n    // logs: 1\n\n\n\n\nAsyncIterable interface\n\n\nObservable\ns implement interface for asynchronous iteration with \nfor..await..of\n looping.\n\n\nlet source = new Observable()\n(async () =\n {\n    for await (let value of source) {\n        console.log(value)\n    }\n})()\nsource.next(1)\nsource.next(2)\n// logs 1\n// logs 2\n\n\n\n\nObserver interface\n\n\n\n\nnext\n\n\n(nextValue: T) =\n void\n\n\nSends value signal through the \nObservable\n instance. \nValues can be received, by \n.subscribe\n, \n.toPromise\n, \n.then\n methods \nor through asynchronous iteration over the \nObservable\n.\n\n\n\n\nerror\n\n\n(error: Error) =\n void\n\n\nSends error signal through the \nObservable\n instance. Errors can be received, with \n.subscribe\n method.\n\n\n\n\ncomplete\n\n\n() =\n void\n\n\nSends \ncomplete\n signal through the \nObservable\n instance. Completion can be handled, with \n.subscribe\n method.\n\n\nOperators - common\n\n\n\n\nmap\n\n\n(action: (value: T) =\n U): Observable\nU\n\n\nCreates a derivative stream of values where\nevery value pushed by a parent is transformed with \naction\n function and push further by \nObservable\n -\nresult of this function call.\n\n\n\n\nfilter\n\n\n(filter: (value: T) =\n boolean): Observable\nT\n;\n\n\nCreates a derivative stream of values where\nonly those values that meet requirements formulated\nwith \nfilter\n function are going to be pushed by that derivative \nObservable\n.\n\n\n\n\nscan\n\n\n(accumulator: (summary: U, value: T, index: number) =\n U, defaultValue?: U): Observable\nU\n\n\nCreates a derivative stream of values where\non every value that parent pushes\nthere is \naccumulator\n function called\ngetting last pushed value and new value that has been pushed by parent \nObservable\n.\nResult of the function is next value of newly created \nObservable\n.\nFirst call is with summary being undefined unless \ndefautValue\n is also passed.\n\n\n\n\nflatten\n\n\n(): Observable\nU\n\n\nWhen parent \nObservable\n is releasing other \nObservable\ns as values\nuse \nflatten\n to create a derivative stream that consists only of values\nthat are released by these \"observable values\".\n\n\n\n\nmerge\n\n\n`(...args: Observable\n;[]): Observable\n;\n\n\nCreates a stream containing all values of parent and of provided in arguments streams.\n\n\n\n\ndistinct\n\n\n(comparator?: (prev: T, next: T) =\n boolean): Observable\nT\n;\n\n\nCreates a derivative stream of values\nbut eliminates repeated subsequent value occurences.\n\n\nIf \ncomparator\n is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.\n\n\n\n\nbuffer\n\n\n(maxLastValues: number = 0): Observable\nT[]\n\n\nCreates a derivative stream of parent \nObservable\n values gathered in array.\nNew values set is released after\nall other \nObservable\ns values are pushed through\nand all \nDomain\n actions being called.\nYou can specify how many of there messages has to be remembered.\n\n\n\n\nmaterialize\n\n\n(defaultState: T): Atom\nT\n\n\nCreates a derivative stream with an \nAtom\n where all values pushed by source are pushed by this node too.\nResulting \nAtom\n will start with \ndefaultState\n state value.\n\n\nasync function example() {\n    const a = new Observable().materialize(1)\n    await leThreeHoursLater()\n    console.log(a.deref()) // logs '1'\n}\n\n\n\n\nOperators - specific\n\n\n\n\nstartWith\n\n\n(firstValue: T): Observable\nT\n;\n\n\nCreates a derivative stream of values where\nit has all values of parent stream, but these are preceeded\nwith \nfirstValue\n that is immediately shared with all other nodes\nthat subscribed to the newly created stream.\n\n\n\n\nbufferCount\n\n\n(bufferSize: number, customBufferCount: number = null): Observable\nT[]\n\n\nCreates a derivative stream containing parent \nObservable\n values\ngathered in an Array.\nNew values set is released\nevery \nbufferSize\n-th parent \nObservable\n value or\nevery \ncustomBufferCount\n-th parent \nObservable\n value\nif second argument is present.\n\n\nAs it might be still mysterious how it works\nconsider these graphical representations\nof how values are pushed in time:\n\n\nconst a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(2)\n\na --1--2--3--4--5--|\nb -----[1,2]-[3,4]-[5]|\n\n\n\n\nconst a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(3, 2) // now with custom window\n\na --1--2--3-------4--5-|\nb --------[1,2,3]----[3,4,5]-|\n\n\n\n\n\n\nreemit\n\n\n(): Observable\nT\n\n\nCreates a derivative stream where all values pushed by source are pushed by this node too,\nbut also this new one will push at first last value that has been emited by the source,\nif that is available.\n\n\nasync function example() {\n    const a = new Observable().startWith(1)\n    await leThreeHoursLater()\n    const b = a.reemit()\n    b.subscribe(value =\n console.log(value)) // logs '1'\n}", 
            "title": "Observable"
        }, 
        {
            "location": "/Observable/#class-observablet", 
            "text": "new (subscriber: (observer: {next: (value: T) =  void, error: (err: Error) =  void, complete: () =  void}) =  void | () =  void)  Construct with  subscriber  function that receives  observer  object.  Observer  is for pushing values, errors and completion signal.  Subscriber  function may return function that should be called if  Observable  receives  complete  signal or is cancelled.", 
            "title": "class Observable&lt;T&gt;"
        }, 
        {
            "location": "/Observable/#static-of", 
            "text": "(...args: T[]): Observable T ;  Function to create an  Observable  that immediately pushes values given as arguments.   Important  Stream is immediately completed after all values are pushed.   If you wish to create a stream and kickstart it with a value(s), use  startWith .", 
            "title": "static of"
        }, 
        {
            "location": "/Observable/#static-from", 
            "text": "(values: T[]): Observable T ;  Function to create an  Observable  that immediately pushes values given as an array of values.   Important  Stream is immediately completed after all values are pushed.   If you wish to create a stream and kickstart it with a value(s), use  startWith .", 
            "title": "static from"
        }, 
        {
            "location": "/Observable/#static-frompromise", 
            "text": "(values: Promise T ): Observable T  Function to create an  Observable  that pushes a value\nrevealed with provided  Promise  and then completes\nas no more values to get from it.", 
            "title": "static fromPromise"
        }, 
        {
            "location": "/Observable/#subscribable-interface", 
            "text": "", 
            "title": "Subscribable interface"
        }, 
        {
            "location": "/Observable/#subscribe", 
            "text": "({  start: (sub: Subscription) =  void,  next: (value: T) =  void,  error: (err: Error) =  void,  complete: () =  void  } ) =  { unsubscribe(): void }  (  onNext?: (value: T) =  void,  onError?: (err: Error) =  void,  onCompletion?: () =  void  ) =  { unsubscribe(): void }  Registers a function called every time when the Observable changes value that it holds, error is pushed or Observable is complete.  Returns a function to unregister the subscription.", 
            "title": "subscribe"
        }, 
        {
            "location": "/Observable/#topromise", 
            "text": "() =  Promise T  Returns next  value  that's going to be pushed through the  Observable  instance.  // Example\nconst source = new Observable()\nsetTimeout(() =  source.next(1), 100)\nconst value = await source.toPromise()", 
            "title": "toPromise"
        }, 
        {
            "location": "/Observable/#promise-interface", 
            "text": "Observable s are also implementing interface of a  Promise ,\n so it actually is possible to deref as if  Observable  was a  Promise \n and use it both with  .then  and  async..await", 
            "title": "Promise interface"
        }, 
        {
            "location": "/Observable/#with-await", 
            "text": "(async () =  {\n    console.log(\n        await new Observable(observer =  { observer.next(1) })\n    )\n    // logs: 1\n})()", 
            "title": "with await"
        }, 
        {
            "location": "/Observable/#then", 
            "text": "U (onsuccess?: (value: T) =  Promise U  | U, onrejection?: (reason: any) =  any): Promise U      new Observable(\n        observer =  { observer.next(1) }).then(_ =  console.log(_)\n    )\n    // logs: 1", 
            "title": "then"
        }, 
        {
            "location": "/Observable/#asynciterable-interface", 
            "text": "Observable s implement interface for asynchronous iteration with  for..await..of  looping.  let source = new Observable()\n(async () =  {\n    for await (let value of source) {\n        console.log(value)\n    }\n})()\nsource.next(1)\nsource.next(2)\n// logs 1\n// logs 2", 
            "title": "AsyncIterable interface"
        }, 
        {
            "location": "/Observable/#observer-interface", 
            "text": "", 
            "title": "Observer interface"
        }, 
        {
            "location": "/Observable/#next", 
            "text": "(nextValue: T) =  void  Sends value signal through the  Observable  instance. \nValues can be received, by  .subscribe ,  .toPromise ,  .then  methods \nor through asynchronous iteration over the  Observable .", 
            "title": "next"
        }, 
        {
            "location": "/Observable/#error", 
            "text": "(error: Error) =  void  Sends error signal through the  Observable  instance. Errors can be received, with  .subscribe  method.", 
            "title": "error"
        }, 
        {
            "location": "/Observable/#complete", 
            "text": "() =  void  Sends  complete  signal through the  Observable  instance. Completion can be handled, with  .subscribe  method.", 
            "title": "complete"
        }, 
        {
            "location": "/Observable/#operators-common", 
            "text": "", 
            "title": "Operators - common"
        }, 
        {
            "location": "/Observable/#map", 
            "text": "(action: (value: T) =  U): Observable U  Creates a derivative stream of values where\nevery value pushed by a parent is transformed with  action  function and push further by  Observable  -\nresult of this function call.", 
            "title": "map"
        }, 
        {
            "location": "/Observable/#filter", 
            "text": "(filter: (value: T) =  boolean): Observable T ;  Creates a derivative stream of values where\nonly those values that meet requirements formulated\nwith  filter  function are going to be pushed by that derivative  Observable .", 
            "title": "filter"
        }, 
        {
            "location": "/Observable/#scan", 
            "text": "(accumulator: (summary: U, value: T, index: number) =  U, defaultValue?: U): Observable U  Creates a derivative stream of values where\non every value that parent pushes\nthere is  accumulator  function called\ngetting last pushed value and new value that has been pushed by parent  Observable .\nResult of the function is next value of newly created  Observable .\nFirst call is with summary being undefined unless  defautValue  is also passed.", 
            "title": "scan"
        }, 
        {
            "location": "/Observable/#flatten", 
            "text": "(): Observable U  When parent  Observable  is releasing other  Observable s as values\nuse  flatten  to create a derivative stream that consists only of values\nthat are released by these \"observable values\".", 
            "title": "flatten"
        }, 
        {
            "location": "/Observable/#merge", 
            "text": "`(...args: Observable ;[]): Observable ;  Creates a stream containing all values of parent and of provided in arguments streams.", 
            "title": "merge"
        }, 
        {
            "location": "/Observable/#distinct", 
            "text": "(comparator?: (prev: T, next: T) =  boolean): Observable T ;  Creates a derivative stream of values\nbut eliminates repeated subsequent value occurences.  If  comparator  is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.", 
            "title": "distinct"
        }, 
        {
            "location": "/Observable/#buffer", 
            "text": "(maxLastValues: number = 0): Observable T[]  Creates a derivative stream of parent  Observable  values gathered in array.\nNew values set is released after\nall other  Observable s values are pushed through\nand all  Domain  actions being called.\nYou can specify how many of there messages has to be remembered.", 
            "title": "buffer"
        }, 
        {
            "location": "/Observable/#materialize", 
            "text": "(defaultState: T): Atom T  Creates a derivative stream with an  Atom  where all values pushed by source are pushed by this node too.\nResulting  Atom  will start with  defaultState  state value.  async function example() {\n    const a = new Observable().materialize(1)\n    await leThreeHoursLater()\n    console.log(a.deref()) // logs '1'\n}", 
            "title": "materialize"
        }, 
        {
            "location": "/Observable/#operators-specific", 
            "text": "", 
            "title": "Operators - specific"
        }, 
        {
            "location": "/Observable/#startwith", 
            "text": "(firstValue: T): Observable T ;  Creates a derivative stream of values where\nit has all values of parent stream, but these are preceeded\nwith  firstValue  that is immediately shared with all other nodes\nthat subscribed to the newly created stream.", 
            "title": "startWith"
        }, 
        {
            "location": "/Observable/#buffercount", 
            "text": "(bufferSize: number, customBufferCount: number = null): Observable T[]  Creates a derivative stream containing parent  Observable  values\ngathered in an Array.\nNew values set is released\nevery  bufferSize -th parent  Observable  value or\nevery  customBufferCount -th parent  Observable  value\nif second argument is present.  As it might be still mysterious how it works\nconsider these graphical representations\nof how values are pushed in time:  const a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(2)\n\na --1--2--3--4--5--|\nb -----[1,2]-[3,4]-[5]|  const a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(3, 2) // now with custom window\n\na --1--2--3-------4--5-|\nb --------[1,2,3]----[3,4,5]-|", 
            "title": "bufferCount"
        }, 
        {
            "location": "/Observable/#reemit", 
            "text": "(): Observable T  Creates a derivative stream where all values pushed by source are pushed by this node too,\nbut also this new one will push at first last value that has been emited by the source,\nif that is available.  async function example() {\n    const a = new Observable().startWith(1)\n    await leThreeHoursLater()\n    const b = a.reemit()\n    b.subscribe(value =  console.log(value)) // logs '1'\n}", 
            "title": "reemit"
        }, 
        {
            "location": "/Atom/", 
            "text": "class \nAtom\nT\n\n\nnew (initialState: T)\n\n\nInstantiate an \nAtom\n with it's default state.\n\n\n\n\nstatic \nof\n\n\n(...args: T[]): Atom\nT\n;\n\n\nFunction to create an \nAtom\n that's state set to last given argument.\n\n\nconst a = Atom.of(1, 2, 3)\nconsole.log(a.deref()) // 3\n\n\n\n\n\n\nImportant\n\n\nStream is immediately completed after all values are pushed.\n\n\n\n\n\n\nstatic \nfrom\n\n\n(values: T[]): Atom\nT\n;\n\n\nFunction to create an \nAtom\n that's state set to last value of an \nIterable\n.\nGiven other \nAtom\n, copies it's state.\n\n\n\n\nImportant\n\n\nStream is immediately completed after all values are pushed.\n\n\n\n\nSubscribable interface\n\n\n\n\nsubscribe\n\n\n({\n\n\nstart: (sub: Subscription) =\n void,\n\n\nnext: (value: T) =\n void,\n\n\nerror: (err: Error) =\n void,\n\n\ncomplete: () =\n void\n\n\n} ) =\n { unsubscribe(): void }\n\n\nnew Atom(0).subscribe({\n    start(){},\n    next(value){ console.log(value) },\n    error(){}\n    complete(){}\n})\n\n\n\n\n(\n\n\nonNext?: (value: T) =\n void,\n\n\nonError?: (err: Error) =\n void,\n\n\nonCompletion?: () =\n void\n\n\n) =\n { unsubscribe(): void }\n\n\nnew Atom(0).subscribe(\n    function onNext(value) { console.log(value) }\n)\n\n\n\n\nRegisters a function called every time when the \nAtom\n changes value that it holds, error is pushed or \nAtom\n is complete.\n\n\nReturns a function to unregister the subscription.\n\n\n\n\ntoPromise\n\n\n() =\n Promise\nT\n\n\nReturns \nvalue\n that's has been pushed through the \nAtom\n instance.\n\nYou should not use that method if you know for sure, you are using an \nAtom\n.\n\nMethod has been implemented, so \nAtom\n have common interface with an \nObservable\n.\n\n\n// Example\nconst source = new Atom()\nsetTimeout(() =\n source.next(1), 100)\nconst value = await source.toPromise()\n\n\n\n\nPromise interface\n\n\nAtom\ns are also implementing interface of a \nPromise\n,\n so it actually is possible to deref as if \nAtom\n was a \nPromise\n\n and use it both with \n.then\n and \nasync..await\n\n\nwith \nawait\n\n\n(async function () {\n    console.log(await new Atom(1)) // logs: 1\n})()\n\n\n\n\nthen\n\n\nU\n(onsuccess?: (value: T) =\n Promise\nU\n | U, onrejection?: (reason: any) =\n any): Promise\nU\n\n\nnew Atom(1).then(_ =\n console.log(_)) // logs: 1\n\n\n\n\n\n\nNotice\n\n\nAtom\n as \nPromise\n will resolve immediately, so if you would like to use it to asynchronously iterate over subsequent values emitted by the \nAtom\n you should first convert it to \nObservable\n with \n.vaporize\n. Interface has been implemented so it is compatible with \nObservable\n.\n\n\n\n\nAsyncIterable interface\n\n\nObservable\ns implement interface for asynchronous iteration with \nfor..await..of\n looping.\n\n\nlet source = new Observable()\n(async () =\n {\n   for await (let value of source) {\n       console.log(value)\n   }\n})()\nsource.next(1)\nsource.next(2)\n// logs 1\n// logs 2\n\n\n\n\nObserver interface\n\n\n\n\nnext\n\n\n(nextValue: T) =\n void\n\n\nSends value signal through the \nAtom\n instance.\nValues can be received, by \n.subscribe\n, \n.toPromise\n, \n.then\n methods\nor through asynchronous iteration over the \nAtom\n.\n\n\n\n\nerror\n\n\n(error: Error) =\n void\n\n\nSends error signal through the \nAtom\n instance. Errors can be received, with \n.subscribe\n method.\n\n\n\n\ncomplete\n\n\n() =\n void\n\n\nSends \ncomplete\n signal through the \nAtom\n instance. Completion can be handled, with \n.subscribe\n method.\n\n\nOperators - common\n\n\n\n\nmap\n\n\n(action: (value: T) =\n U): Atom\nU\n\n\nCreates a derivative stream of values where\nevery value pushed by a parent is transformed with \naction\n function and push further by \nAtom\n -\nresult of this function call.\n\n\n\n\nfilter\n\n\n(filter: (value: T) =\n boolean): Atom\nT\n;\n\n\nCreates a derivative stream of values where\nonly those values that meet requirements formulated\nwith \nfilter\n function are going to be pushed by that derivative \nAtom\n.\n\n\n\n\nWarning\n\n\nFirst value of \nAtom\n is not validated by provided function.\n\nAtom\n instance has to always have a state.\n\n\n\n\n\n\nscan\n\n\n(accumulator: (summary: U, value: T, index: number) =\n U, defaultValue?: U): Atom\nU\n\n\nCreates a derivative stream of values where\non every value that parent pushes\nthere is \naccumulator\n function called\ngetting last pushed value and new value that has been pushed by parent \nAtom\n.\nResult of the function is next value of newly created \nAtom\n.\nFirst call is with summary being undefined unless \ndefautValue\n is also passed.\n\n\n\n\nflatten\n\n\n(): Atom\nU\n\n\nWhen parent \nAtom\n is releasing other \nAtom\ns as values\nuse \nflatten\n to create a derivative stream that consists only of values\nthat are released by these \"Atom values\".\n\n\n\n\nmerge\n\n\n`(...args: Atom\n;[]): Atom\n;\n\n\nCreates a stream containing all values of parent and of provided in arguments streams.\n\n\n\n\ndistinct\n\n\n(comparator?: (prev: T, next: T) =\n boolean): Atom\nT\n;\n\n\nCreates a derivative stream of values\nbut eliminates repeated subsequent value occurences.\n\n\nIf \ncomparator\n is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.\n\n\n\n\nbuffer\n\n\n(maxLastValues: number = 0): Atom\nT[]\n\n\nCreates a derivative stream of parent \nAtom\n values gathered in array.\nNew values set is released after\nall other \nAtom\ns values are pushed through\nand all \nDomain\n actions being called.\nYou can specify how many of there messages has to be remembered.\n\n\n\n\nmaterialize\n\n\n(defaultState: T): Atom\nT\n\n\nReturns itself.\n\n\n\n\nvaporize\n\n\n(): Observable\nT\n\n\nReturns an \nObservable\n that is subscriber to the source \nAtom\n.", 
            "title": "Atom"
        }, 
        {
            "location": "/Atom/#class-atomt", 
            "text": "new (initialState: T)  Instantiate an  Atom  with it's default state.", 
            "title": "class Atom&lt;T&gt;"
        }, 
        {
            "location": "/Atom/#static-of", 
            "text": "(...args: T[]): Atom T ;  Function to create an  Atom  that's state set to last given argument.  const a = Atom.of(1, 2, 3)\nconsole.log(a.deref()) // 3   Important  Stream is immediately completed after all values are pushed.", 
            "title": "static of"
        }, 
        {
            "location": "/Atom/#static-from", 
            "text": "(values: T[]): Atom T ;  Function to create an  Atom  that's state set to last value of an  Iterable .\nGiven other  Atom , copies it's state.   Important  Stream is immediately completed after all values are pushed.", 
            "title": "static from"
        }, 
        {
            "location": "/Atom/#subscribable-interface", 
            "text": "", 
            "title": "Subscribable interface"
        }, 
        {
            "location": "/Atom/#subscribe", 
            "text": "({  start: (sub: Subscription) =  void,  next: (value: T) =  void,  error: (err: Error) =  void,  complete: () =  void  } ) =  { unsubscribe(): void }  new Atom(0).subscribe({\n    start(){},\n    next(value){ console.log(value) },\n    error(){}\n    complete(){}\n})  (  onNext?: (value: T) =  void,  onError?: (err: Error) =  void,  onCompletion?: () =  void  ) =  { unsubscribe(): void }  new Atom(0).subscribe(\n    function onNext(value) { console.log(value) }\n)  Registers a function called every time when the  Atom  changes value that it holds, error is pushed or  Atom  is complete.  Returns a function to unregister the subscription.", 
            "title": "subscribe"
        }, 
        {
            "location": "/Atom/#topromise", 
            "text": "() =  Promise T  Returns  value  that's has been pushed through the  Atom  instance. You should not use that method if you know for sure, you are using an  Atom . \nMethod has been implemented, so  Atom  have common interface with an  Observable .  // Example\nconst source = new Atom()\nsetTimeout(() =  source.next(1), 100)\nconst value = await source.toPromise()", 
            "title": "toPromise"
        }, 
        {
            "location": "/Atom/#promise-interface", 
            "text": "Atom s are also implementing interface of a  Promise ,\n so it actually is possible to deref as if  Atom  was a  Promise \n and use it both with  .then  and  async..await", 
            "title": "Promise interface"
        }, 
        {
            "location": "/Atom/#with-await", 
            "text": "(async function () {\n    console.log(await new Atom(1)) // logs: 1\n})()", 
            "title": "with await"
        }, 
        {
            "location": "/Atom/#then", 
            "text": "U (onsuccess?: (value: T) =  Promise U  | U, onrejection?: (reason: any) =  any): Promise U  new Atom(1).then(_ =  console.log(_)) // logs: 1   Notice  Atom  as  Promise  will resolve immediately, so if you would like to use it to asynchronously iterate over subsequent values emitted by the  Atom  you should first convert it to  Observable  with  .vaporize . Interface has been implemented so it is compatible with  Observable .", 
            "title": "then"
        }, 
        {
            "location": "/Atom/#asynciterable-interface", 
            "text": "Observable s implement interface for asynchronous iteration with  for..await..of  looping.  let source = new Observable()\n(async () =  {\n   for await (let value of source) {\n       console.log(value)\n   }\n})()\nsource.next(1)\nsource.next(2)\n// logs 1\n// logs 2", 
            "title": "AsyncIterable interface"
        }, 
        {
            "location": "/Atom/#observer-interface", 
            "text": "", 
            "title": "Observer interface"
        }, 
        {
            "location": "/Atom/#next", 
            "text": "(nextValue: T) =  void  Sends value signal through the  Atom  instance.\nValues can be received, by  .subscribe ,  .toPromise ,  .then  methods\nor through asynchronous iteration over the  Atom .", 
            "title": "next"
        }, 
        {
            "location": "/Atom/#error", 
            "text": "(error: Error) =  void  Sends error signal through the  Atom  instance. Errors can be received, with  .subscribe  method.", 
            "title": "error"
        }, 
        {
            "location": "/Atom/#complete", 
            "text": "() =  void  Sends  complete  signal through the  Atom  instance. Completion can be handled, with  .subscribe  method.", 
            "title": "complete"
        }, 
        {
            "location": "/Atom/#operators-common", 
            "text": "", 
            "title": "Operators - common"
        }, 
        {
            "location": "/Atom/#map", 
            "text": "(action: (value: T) =  U): Atom U  Creates a derivative stream of values where\nevery value pushed by a parent is transformed with  action  function and push further by  Atom  -\nresult of this function call.", 
            "title": "map"
        }, 
        {
            "location": "/Atom/#filter", 
            "text": "(filter: (value: T) =  boolean): Atom T ;  Creates a derivative stream of values where\nonly those values that meet requirements formulated\nwith  filter  function are going to be pushed by that derivative  Atom .   Warning  First value of  Atom  is not validated by provided function. Atom  instance has to always have a state.", 
            "title": "filter"
        }, 
        {
            "location": "/Atom/#scan", 
            "text": "(accumulator: (summary: U, value: T, index: number) =  U, defaultValue?: U): Atom U  Creates a derivative stream of values where\non every value that parent pushes\nthere is  accumulator  function called\ngetting last pushed value and new value that has been pushed by parent  Atom .\nResult of the function is next value of newly created  Atom .\nFirst call is with summary being undefined unless  defautValue  is also passed.", 
            "title": "scan"
        }, 
        {
            "location": "/Atom/#flatten", 
            "text": "(): Atom U  When parent  Atom  is releasing other  Atom s as values\nuse  flatten  to create a derivative stream that consists only of values\nthat are released by these \"Atom values\".", 
            "title": "flatten"
        }, 
        {
            "location": "/Atom/#merge", 
            "text": "`(...args: Atom ;[]): Atom ;  Creates a stream containing all values of parent and of provided in arguments streams.", 
            "title": "merge"
        }, 
        {
            "location": "/Atom/#distinct", 
            "text": "(comparator?: (prev: T, next: T) =  boolean): Atom T ;  Creates a derivative stream of values\nbut eliminates repeated subsequent value occurences.  If  comparator  is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.", 
            "title": "distinct"
        }, 
        {
            "location": "/Atom/#buffer", 
            "text": "(maxLastValues: number = 0): Atom T[]  Creates a derivative stream of parent  Atom  values gathered in array.\nNew values set is released after\nall other  Atom s values are pushed through\nand all  Domain  actions being called.\nYou can specify how many of there messages has to be remembered.", 
            "title": "buffer"
        }, 
        {
            "location": "/Atom/#materialize", 
            "text": "(defaultState: T): Atom T  Returns itself.", 
            "title": "materialize"
        }, 
        {
            "location": "/Atom/#vaporize", 
            "text": "(): Observable T  Returns an  Observable  that is subscriber to the source  Atom .", 
            "title": "vaporize"
        }, 
        {
            "location": "/Combine/", 
            "text": "class Combine\nT\n extends \nAtom\nT\n\n\nnew ({ [name: string]: Observable|Atom|Domain })\n\n\nResponsible for being reactive to more than one source and placing source streams contents in their respective (according to informations provided upon initialization) field in result object.\n\n\nnew Combine({\n    a: new Atom('a'),\n    b: new Atom('b'),\n    c: new Observable(observer =\n { observer.next('c') })\n})\n    .subscribe(v =\n {\n        console.log(v)\n            // { a: 'a', b: 'b', c: null }\n            // { a: 'a', b: 'b', c: 'c' }\n    })\n\n\n\n\nCombine\n is an \nAtom\n extension, therefore .hasRef will always return \ntrue\n. It will close (completes) itself as any of given sources does the same.", 
            "title": "Combine"
        }, 
        {
            "location": "/Combine/#class-combinet-extends-atomt", 
            "text": "new ({ [name: string]: Observable|Atom|Domain })  Responsible for being reactive to more than one source and placing source streams contents in their respective (according to informations provided upon initialization) field in result object.  new Combine({\n    a: new Atom('a'),\n    b: new Atom('b'),\n    c: new Observable(observer =  { observer.next('c') })\n})\n    .subscribe(v =  {\n        console.log(v)\n            // { a: 'a', b: 'b', c: null }\n            // { a: 'a', b: 'b', c: 'c' }\n    })  Combine  is an  Atom  extension, therefore .hasRef will always return  true . It will close (completes) itself as any of given sources does the same.", 
            "title": "class Combine&lt;T&gt; extends Atom&lt;T&gt;"
        }, 
        {
            "location": "/Domain/", 
            "text": "class Domain\nT\n\n\nnew ( source: Observable\nT\n )\n\n\nClass constructor alone will be only helpful when extending \nDomain\n class.\n\n\nYou can create a \nDomain\n either through class inheritance or with factory function \nDomain.create\n.\n\n\nDomain\n have operator functions on prototype\nthat are present both in \nObservable\n and \nAtom\n\nand calling them will actually call operators on stream object\nthat the \nDomain\n has been provided with.\n\n\n\n\nnew Domain through inheritance\n\n\nimport {Combine, Domain, action} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = (() =\n {\n    class EyesDomain extends Domain {\n        constructor() {\n            super(\n                new Combine({\n                    horizon: HorizonDomain,\n                    muscles: MusclesDomain,\n                })\n            )\n        }\n\n        @action\n        roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    }\n    return new EyesDomain()\n})()\n\n\n\n\n\n\nDomain.create\nT\n\n\n(source: Observable\nT\n | Atom\nT\n, actions: { [name: string]: () =\n promise\nlt;any\ngt; | void }, fields?: {}) =\n Domain\n\n\nDomain\n class by design is the only thing that should be exported and used (maybe with an exception of type definitions) outside of \nDomain\ns scope.\n\n\nFor example, if you have a folder like...\n\n\n\u2514 SomeDomain\n  \u251c index.js // just export\n  \u251c SomeDomain.js // here is Domain creation\n  \u251c SomeDomainState.js // downstream - source observables or stream transformations\n  \u2514 SomeDomainActions.js // functions to manipulate `Domain`'s state\n\n\n\n\n...or just...\n\n\n\u2514 SomeDomain.js // everything\n\n\n\n\n...you should export SomeDomain from index.js and use only that in any other JavaScript module.\n\n\nFirst argument of the factory function is an observable emiting messages that will be emited by the \nDomain\n's instance too.\nOnly single data source can be tied to a \nDomain\n, but you can always use \nCombine\n to combine multiple streams.\n\n\nSecond argument is an object aggregating functions used to create actions and other values that will be exposed as part of the \nDomain\n interface.\nProvided functions will be wrapped with an internal Dispatcher calls. That mechanism ensures that they will always be executed one \nafter\n another. That is a design decision which makes it easier to reason about what is happening inside application.\nFunctions provided as \nDomain\n \nactions\n must not return any value.\nCalling an action however will return a Promise resolved after action function execution.\n\n\n// example usage\nimport { Combine, Domain } from 'immview'\nimport { HorizonDomain } from './HorizonDomain'\nimport { MusclesDomain } from './MusclesDomain'\n\nconst EyesDomain = Domain.create(\n    new Combine({\n        horizon: HorizonDomain,\n        muscles: MusclesDomain,\n    }),\n    {\n        roll\n    }\n)\n\nfunction roll() {\n    MusclesDomain.doMuscleStuff()\n}\n\n// usage...\n\nEyesDomain.roll().then(() =\n { console.log('I saw that!') })\n\n\n\n\n\n\nDomainInstance\n.[ACTION_NAME]\n\n\n(...args): Promise\nany\n | void\n\n\nA function that was in a provided in constructor set of actions.\nIt is \nnot\n exactly the same function as provided, because it is wrapped with internal scheduler call.\nBecause it's potentially deferred execution \nit always returns a \nPromise\n resolved with that function result.\nIf function throws, \nPromise\n will be rejected.\n\n\nconst domain = Domain.create(\n    new Observable(observer =\n { ... }),\n    { foo: () =\n console.log('bar') }\n)\ndomain.foo()\n// prints: 'bar'", 
            "title": "Domain"
        }, 
        {
            "location": "/Domain/#class-domaint", 
            "text": "new ( source: Observable T  )  Class constructor alone will be only helpful when extending  Domain  class.  You can create a  Domain  either through class inheritance or with factory function  Domain.create .  Domain  have operator functions on prototype\nthat are present both in  Observable  and  Atom \nand calling them will actually call operators on stream object\nthat the  Domain  has been provided with.", 
            "title": "class Domain&lt;T&gt;"
        }, 
        {
            "location": "/Domain/#new-domain-through-inheritance", 
            "text": "import {Combine, Domain, action} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = (() =  {\n    class EyesDomain extends Domain {\n        constructor() {\n            super(\n                new Combine({\n                    horizon: HorizonDomain,\n                    muscles: MusclesDomain,\n                })\n            )\n        }\n\n        @action\n        roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    }\n    return new EyesDomain()\n})()", 
            "title": "new Domain through inheritance"
        }, 
        {
            "location": "/Domain/#domaincreatet", 
            "text": "(source: Observable T  | Atom T , actions: { [name: string]: () =  promise lt;any gt; | void }, fields?: {}) =  Domain  Domain  class by design is the only thing that should be exported and used (maybe with an exception of type definitions) outside of  Domain s scope.  For example, if you have a folder like...  \u2514 SomeDomain\n  \u251c index.js // just export\n  \u251c SomeDomain.js // here is Domain creation\n  \u251c SomeDomainState.js // downstream - source observables or stream transformations\n  \u2514 SomeDomainActions.js // functions to manipulate `Domain`'s state  ...or just...  \u2514 SomeDomain.js // everything  ...you should export SomeDomain from index.js and use only that in any other JavaScript module.  First argument of the factory function is an observable emiting messages that will be emited by the  Domain 's instance too.\nOnly single data source can be tied to a  Domain , but you can always use  Combine  to combine multiple streams.  Second argument is an object aggregating functions used to create actions and other values that will be exposed as part of the  Domain  interface.\nProvided functions will be wrapped with an internal Dispatcher calls. That mechanism ensures that they will always be executed one  after  another. That is a design decision which makes it easier to reason about what is happening inside application.\nFunctions provided as  Domain   actions  must not return any value.\nCalling an action however will return a Promise resolved after action function execution.  // example usage\nimport { Combine, Domain } from 'immview'\nimport { HorizonDomain } from './HorizonDomain'\nimport { MusclesDomain } from './MusclesDomain'\n\nconst EyesDomain = Domain.create(\n    new Combine({\n        horizon: HorizonDomain,\n        muscles: MusclesDomain,\n    }),\n    {\n        roll\n    }\n)\n\nfunction roll() {\n    MusclesDomain.doMuscleStuff()\n}\n\n// usage...\n\nEyesDomain.roll().then(() =  { console.log('I saw that!') })", 
            "title": "Domain.create&lt;T&gt;"
        }, 
        {
            "location": "/Domain/#domaininstanceaction_name", 
            "text": "(...args): Promise any  | void  A function that was in a provided in constructor set of actions.\nIt is  not  exactly the same function as provided, because it is wrapped with internal scheduler call.\nBecause it's potentially deferred execution  it always returns a  Promise  resolved with that function result.\nIf function throws,  Promise  will be rejected.  const domain = Domain.create(\n    new Observable(observer =  { ... }),\n    { foo: () =  console.log('bar') }\n)\ndomain.foo()\n// prints: 'bar'", 
            "title": "DomainInstance.[ACTION_NAME]"
        }, 
        {
            "location": "/Process/", 
            "text": "class \nProcess\nT\n\n\nProcess\n is a wrapper for a asynchronous function that\nreceives observable that is a message box of that process.\n\n\nProcess\n instance is an observer, so might be used directly as subscriber.\n\n\nconst proc = new Process(\n    async mb =\n {\n        for await (let msg of mb) {\n            console.log(msg)\n        }\n    }\n)\nproc.next(1) // logs 1\nproc.next(2) // logs 2\n\nObservable.of(3, 4).subscribe(mb) // logs 3, then 4, then completes", 
            "title": "Process"
        }, 
        {
            "location": "/Process/#class-processt", 
            "text": "Process  is a wrapper for a asynchronous function that\nreceives observable that is a message box of that process.  Process  instance is an observer, so might be used directly as subscriber.  const proc = new Process(\n    async mb =  {\n        for await (let msg of mb) {\n            console.log(msg)\n        }\n    }\n)\nproc.next(1) // logs 1\nproc.next(2) // logs 2\n\nObservable.of(3, 4).subscribe(mb) // logs 3, then 4, then completes", 
            "title": "class Process&lt;T&gt;"
        }, 
        {
            "location": "/AtomObservableDiff/", 
            "text": "What's the difference between \nAtom\n and \nObservable\n classes?\n\n\nBoth \nAtom\n and \nObservable\n look very similar at first glance,\nbut they really have very different purpose.\n\n\nAtom\n is encapsulated observable state value.\n\n\nObservable\n is encapsulated stream of messages, \nthat is: values that are relevant only at time of their publishing.\n\n\nLet's have this as an example:\n\n\nimport {Atom, Observable} from \nimmview\n\n\nconst a$ = new Atom('-')\na$.next('first')\na$.next('second')\na$.subscribe(v =\n console.log(`A  ${v}`))\n    // logs: A  second\na$.subscribe(v =\n console.log(`A2 ${v}`))\n    // logs: A2 second\na$.next('third')\n    // logs: A  third\n    // logs: A2 third\n\nconst o$ = new Observable(({next}) =\n {next('-')})\no$.next('first')\no$.next('second')\no$.subscribe(v =\n console.log(`O  ${v}`))\n    // logs: O  -\n    // logs: O  first\n    // logs: O  second\no$.subscribe(v =\n console.log(`O2 ${v}`))\no$.next('third')\n    // logs: O  third\n    // logs: O2 third\n\nlog.join('\\n')\n\n\n\n\n\n\nsee that running live on https://runkit.com/arturkulig/immview-atom-observable-difference\n\n\n\n\nAs you can see first few values pushed through the \na$ (Atom)\n \nare lost\n.\nThis is because these previous values are not that \nAtom\n's state anymore. It will allow reading it's value to every subscriber and will notify these subscribers if state changes, but it is not a message queue, so previous states are not relevant.\n\n\nObservable\n on the other hand is just \na message queue\n. No message is lost and all queued messages are dispatched to subscribers as soon as possible. You can make sure that all subscriptions are created by the time first value is pushed, so all of them are notified of all messages, but that is up to a library user, it might not be important after all.\n\n\nWhere to use which?\n\n\nDifferent nature of both of these streaming primitives may be still unclear? More real-life example might be of use.\n\n\nConsider connectivity through HTTP tooling prepared with \nImmview\n. In case you want to broadcast structures that inform about fetching status of different resources you'd use an \nObservable\n, but if you wish to maintain a registry of requesting and finally - content of  every requested remote resource - you'd prefer an \nAtom\n for the job.\n\n\nYou might as well have both! First an \nObservable\n that just broadcasts requests status and then an \nAtom\n (might be even in different \nDomain\n) that reduces these messages to a single structure that contains information about all resources.", 
            "title": "Atom or Observable?"
        }, 
        {
            "location": "/AtomObservableDiff/#whats-the-difference-between-atom-and-observable-classes", 
            "text": "Both  Atom  and  Observable  look very similar at first glance,\nbut they really have very different purpose.  Atom  is encapsulated observable state value.  Observable  is encapsulated stream of messages, \nthat is: values that are relevant only at time of their publishing.  Let's have this as an example:  import {Atom, Observable} from  immview \n\nconst a$ = new Atom('-')\na$.next('first')\na$.next('second')\na$.subscribe(v =  console.log(`A  ${v}`))\n    // logs: A  second\na$.subscribe(v =  console.log(`A2 ${v}`))\n    // logs: A2 second\na$.next('third')\n    // logs: A  third\n    // logs: A2 third\n\nconst o$ = new Observable(({next}) =  {next('-')})\no$.next('first')\no$.next('second')\no$.subscribe(v =  console.log(`O  ${v}`))\n    // logs: O  -\n    // logs: O  first\n    // logs: O  second\no$.subscribe(v =  console.log(`O2 ${v}`))\no$.next('third')\n    // logs: O  third\n    // logs: O2 third\n\nlog.join('\\n')   see that running live on https://runkit.com/arturkulig/immview-atom-observable-difference   As you can see first few values pushed through the  a$ (Atom)   are lost .\nThis is because these previous values are not that  Atom 's state anymore. It will allow reading it's value to every subscriber and will notify these subscribers if state changes, but it is not a message queue, so previous states are not relevant.  Observable  on the other hand is just  a message queue . No message is lost and all queued messages are dispatched to subscribers as soon as possible. You can make sure that all subscriptions are created by the time first value is pushed, so all of them are notified of all messages, but that is up to a library user, it might not be important after all.", 
            "title": "What's the difference between Atom and Observable classes?"
        }, 
        {
            "location": "/AtomObservableDiff/#where-to-use-which", 
            "text": "Different nature of both of these streaming primitives may be still unclear? More real-life example might be of use.  Consider connectivity through HTTP tooling prepared with  Immview . In case you want to broadcast structures that inform about fetching status of different resources you'd use an  Observable , but if you wish to maintain a registry of requesting and finally - content of  every requested remote resource - you'd prefer an  Atom  for the job.  You might as well have both! First an  Observable  that just broadcasts requests status and then an  Atom  (might be even in different  Domain ) that reduces these messages to a single structure that contains information about all resources.", 
            "title": "Where to use which?"
        }
    ]
}