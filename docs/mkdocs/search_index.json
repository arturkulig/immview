{
    "docs": [
        {
            "location": "/", 
            "text": "Immview\n is a library to create \nDomain\ns - \nnon-visual components\n -\nsimilar to flux stores, exposing their \nstate\n or emitting \nsignals\n\nthrough \nObservable\ns pushing values and having specific to their concerns \nactions\n.\nTheir primary role is to encapsulate a concern\nand to be the only thing exported from a javascript module or modules\nthat deal with the concern.\n\n\nIt completely replaces any flux implementation or Redux.\n\n\nAll \nDomain\ns must be provided with a single stream of values\n(so either \nOrigin\n or any other transformed \nObservable\n),\nbut not all \nObservable\ns must be attached to a \nDomain\n -\nyou can perform many transformations on a source\nbefore it is exposed through a \nDomain\n.", 
            "title": "Immview"
        }, 
        {
            "location": "/Observable/", 
            "text": "class \nObservable\nT\n\n\n(subscriber: (observer: {next: (value: T) =\n void, error: (err: Error) =\n void, complete: () =\n void}) =\n void | () =\n void)\n\n\nConstruct with \nsubscriber\n function that receives \nobserver\n object. \nObserver\n is for pushing values, errors and completion signal.\n\n\nSubscriber\n function may return function that should be called if \nObservable\n receives \ncomplete\n signal or is cancelled.\n\n\n\n\nObservable.\nof\n\n\n(...args: T[]): Observable\nT\n;\n\n\nFunction to create an \nObservable\n that immediately pushes values given as arguments.\n\n\nStream is immediately completed after all values are pushed.\n\nIf you wish to create a stream and kickstart it with a value(s), use \nstartWith\n.\n\n\n\n\nObservable.\nfrom\n\n\n(values: T[]): Observable\nT\n;\n\n\nFunction to create an \nObservable\n that immediately pushes values given as an array of values.\n\n\nStream is immediately completed after all values are pushed.\n\nIf you wish to create a stream and kickstart it with a value(s), use \nstartWith\n.\n\n\n\n\nObservable.prototype.\nprevious\n\n\n() =\n T\n\n\nReturns previous \nvalue\n that has been pushed through the \nObservable\n instance.\n\n\n// Example\nconst source = new Observable(({next}) =\n { next(1) })\nsource.subscribe(value =\n {\n    value === source.previous() // true\n})\n\n\n\n\n\n\nObservable.prototype.\ntoPromise\n\n\n() =\n T\n\n\nReturns next \nvalue\n that's going to be pushed through the \nObservable\n instance.\n\n\n// Example\nconst source = new Observable()\nsetTimeout(() =\n source.next(1), 100)\nconst value = await source.toPromise()\n\n\n\n\n\n\nObservable.prototype.\nnext\n\n\n(nextValue: T) =\n void\n\n\nSends value signal through the \nObservable\n instance. Values can be received, by \nObservable.prototype.subscribe\n method or \nObservable.prototype.previous\n.\n\n\n\n\nObservable.prototype.\nerror\n\n\n(error: Error) =\n void\n\n\nSends error signal through the \nObservable\n instance. Errors can be received, with \nObservable.prototype.subscribe\n method.\n\n\n\n\nObservable.prototype.\ncomplete\n\n\n() =\n void\n\n\nSends \ncomplete\n signal through the \nObservable\n instance. Completion can be handled, with \nObservable.prototype.subscribe\n method.\n\n\n\n\nObservable.prototype.\nsubscribe\n\n\n( { start: (sub: Subscription) =\n void, next: (value: T) =\n void, error: (err: Error) =\n void, complete: () =\n void } ) =\n { unsubscribe(): void }\n\n\n( onNext?: (value: T) =\n void, onError?: (err: Error) =\n void, onCompletion?: () =\n void ) =\n { unsubscribe(): void }\n\n\nRegisters a function called every time when the Observable changes value that it holds, error is pushed or Observable is complete.\n\n\nReturns a function to unregister the subscription.\n\n\n\n\nObservable.prototype.\nmap\n\n\n(action: (value: T) =\n U): Observable\nU\n\n\nCreates a derivative stream of values where\nevery value pushed by a parent is transformed with \naction\n function and push further by \nObservable\n -\nresult of this function call.\n\n\n\n\nObservable.prototype.\nstartWith\n\n\n(firstValue: T): Observable\nT\n;\n\n\nCreates a derivative stream of values where\nit has all values of parent stream, but these are preceeded\nwith \nfirstValue\n that is immediately shared with all other nodes\nthat subscribed to the newly created stream.\n\n\n\n\nObservable.prototype.\nfilter\n\n\n(filter: (value: T) =\n boolean): Observable\nT\n;\n\n\nCreates a derivative stream of values where\nonly those values that meet requirements formulated\nwith \nfilter\n function are going to be pushed by that derivative \nObservable\n.\n\n\n\n\nObservable.prototype.\nscan\n\n\n(accumulator: (summary: U, value: T, index: number) =\n U, defaultValue?: U): Observable\nU\n\n\nCreates a derivative stream of values where\non every value that parent pushes\nthere is \naccumulator\n function called\ngetting last pushed value and new value that has been pushed by parent \nObservable\n.\nResult of the function is next value of newly created \nObservable\n.\nFirst call is with summary being undefined unless \ndefautValue\n is also passed.\n\n\n\n\nObservable.prototype.\nflatten\n\n\n(): Observable\nU\n\n\nWhen parent \nObservable\n is releasing other \nObservable\ns as values\nuse \nflatten\n to create a derivative stream that consists only of values\nthat are released by these \"observable values\".\n\n\n\n\nObservable.prototype.\nmerge\n\n\n`(...args: Observable\n;[]): Observable\n;\n\n\nCreates a stream containing all values of parent and of provided in arguments streams.\n\n\n\n\nObservable.prototype.\ndistinct\n\n\n(comparator?: (prev: T, next: T) =\n boolean): Observable\nT\n;\n\n\nCreates a derivative stream of values\nbut eliminates repeated subsequent value occurences.\n\n\nIf \ncomparator\n is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.\n\n\n\n\nObservable.prototype.\nbuffer\n\n\n(maxLastValues: number = 0): Observable\nT[]\n\n\nCreates a derivative stream of parent \nObservable\n values gathered in array.\nNew values set is released after\nall other \nObservable\ns values are pushed through\nand all \nDomain\n actions being called.\nYou can specify how many of there messages has to be remembered.\n\n\n\n\nObservable.prototype.\nbufferCount\n\n\n(bufferSize: number, customBufferCount: number = null): Observable\nT[]\n\n\nCreates a derivative stream containing parent \nObservable\n values\ngathered in an Array.\nNew values set is released\nevery \nbufferSize\n-th parent \nObservable\n value or\nevery \ncustomBufferCount\n-th parent \nObservable\n value\nif second argument is present.\n\n\nAs it might be still mysterious how it works\nconsider these graphical representations\nof how values are pushed in time:\n\n\nconst a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(2)\n\na --1--2--3--4--5--|\nb -----[1,2]-[3,4]-[5]|\n\n\n\n\nconst a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(3, 2) // now with custom window\n\na --1--2--3-------4--5-|\nb --------[1,2,3]----[3,4,5]-|\n\n\n\n\n\n\nObservable.prototype.\nreemit\n\n\n(): Observable\nT\n\n\nCreates a derivative stream where all values pushed by source are pushed by this node too,\nbut also this new one will push at first last value that has been pushed by source in the past,\nif any was actually pushed.\n\n\nasync function example() {\n    const a = new Observable().startWith(1)\n    await leThreeHoursLater()\n    const b = a.reemit()\n    console.log(await b.toPromise()) // logs '1'\n}", 
            "title": "Observable"
        }, 
        {
            "location": "/Observable/#class-observablet", 
            "text": "(subscriber: (observer: {next: (value: T) =  void, error: (err: Error) =  void, complete: () =  void}) =  void | () =  void)  Construct with  subscriber  function that receives  observer  object.  Observer  is for pushing values, errors and completion signal.  Subscriber  function may return function that should be called if  Observable  receives  complete  signal or is cancelled.", 
            "title": "class Observable&lt;T&gt;"
        }, 
        {
            "location": "/Observable/#observableof", 
            "text": "(...args: T[]): Observable T ;  Function to create an  Observable  that immediately pushes values given as arguments.  Stream is immediately completed after all values are pushed. \nIf you wish to create a stream and kickstart it with a value(s), use  startWith .", 
            "title": "Observable.of"
        }, 
        {
            "location": "/Observable/#observablefrom", 
            "text": "(values: T[]): Observable T ;  Function to create an  Observable  that immediately pushes values given as an array of values.  Stream is immediately completed after all values are pushed. \nIf you wish to create a stream and kickstart it with a value(s), use  startWith .", 
            "title": "Observable.from"
        }, 
        {
            "location": "/Observable/#observableprototypeprevious", 
            "text": "() =  T  Returns previous  value  that has been pushed through the  Observable  instance.  // Example\nconst source = new Observable(({next}) =  { next(1) })\nsource.subscribe(value =  {\n    value === source.previous() // true\n})", 
            "title": "Observable.prototype.previous"
        }, 
        {
            "location": "/Observable/#observableprototypetopromise", 
            "text": "() =  T  Returns next  value  that's going to be pushed through the  Observable  instance.  // Example\nconst source = new Observable()\nsetTimeout(() =  source.next(1), 100)\nconst value = await source.toPromise()", 
            "title": "Observable.prototype.toPromise"
        }, 
        {
            "location": "/Observable/#observableprototypenext", 
            "text": "(nextValue: T) =  void  Sends value signal through the  Observable  instance. Values can be received, by  Observable.prototype.subscribe  method or  Observable.prototype.previous .", 
            "title": "Observable.prototype.next"
        }, 
        {
            "location": "/Observable/#observableprototypeerror", 
            "text": "(error: Error) =  void  Sends error signal through the  Observable  instance. Errors can be received, with  Observable.prototype.subscribe  method.", 
            "title": "Observable.prototype.error"
        }, 
        {
            "location": "/Observable/#observableprototypecomplete", 
            "text": "() =  void  Sends  complete  signal through the  Observable  instance. Completion can be handled, with  Observable.prototype.subscribe  method.", 
            "title": "Observable.prototype.complete"
        }, 
        {
            "location": "/Observable/#observableprototypesubscribe", 
            "text": "( { start: (sub: Subscription) =  void, next: (value: T) =  void, error: (err: Error) =  void, complete: () =  void } ) =  { unsubscribe(): void }  ( onNext?: (value: T) =  void, onError?: (err: Error) =  void, onCompletion?: () =  void ) =  { unsubscribe(): void }  Registers a function called every time when the Observable changes value that it holds, error is pushed or Observable is complete.  Returns a function to unregister the subscription.", 
            "title": "Observable.prototype.subscribe"
        }, 
        {
            "location": "/Observable/#observableprototypemap", 
            "text": "(action: (value: T) =  U): Observable U  Creates a derivative stream of values where\nevery value pushed by a parent is transformed with  action  function and push further by  Observable  -\nresult of this function call.", 
            "title": "Observable.prototype.map"
        }, 
        {
            "location": "/Observable/#observableprototypestartwith", 
            "text": "(firstValue: T): Observable T ;  Creates a derivative stream of values where\nit has all values of parent stream, but these are preceeded\nwith  firstValue  that is immediately shared with all other nodes\nthat subscribed to the newly created stream.", 
            "title": "Observable.prototype.startWith"
        }, 
        {
            "location": "/Observable/#observableprototypefilter", 
            "text": "(filter: (value: T) =  boolean): Observable T ;  Creates a derivative stream of values where\nonly those values that meet requirements formulated\nwith  filter  function are going to be pushed by that derivative  Observable .", 
            "title": "Observable.prototype.filter"
        }, 
        {
            "location": "/Observable/#observableprototypescan", 
            "text": "(accumulator: (summary: U, value: T, index: number) =  U, defaultValue?: U): Observable U  Creates a derivative stream of values where\non every value that parent pushes\nthere is  accumulator  function called\ngetting last pushed value and new value that has been pushed by parent  Observable .\nResult of the function is next value of newly created  Observable .\nFirst call is with summary being undefined unless  defautValue  is also passed.", 
            "title": "Observable.prototype.scan"
        }, 
        {
            "location": "/Observable/#observableprototypeflatten", 
            "text": "(): Observable U  When parent  Observable  is releasing other  Observable s as values\nuse  flatten  to create a derivative stream that consists only of values\nthat are released by these \"observable values\".", 
            "title": "Observable.prototype.flatten"
        }, 
        {
            "location": "/Observable/#observableprototypemerge", 
            "text": "`(...args: Observable ;[]): Observable ;  Creates a stream containing all values of parent and of provided in arguments streams.", 
            "title": "Observable.prototype.merge"
        }, 
        {
            "location": "/Observable/#observableprototypedistinct", 
            "text": "(comparator?: (prev: T, next: T) =  boolean): Observable T ;  Creates a derivative stream of values\nbut eliminates repeated subsequent value occurences.  If  comparator  is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.", 
            "title": "Observable.prototype.distinct"
        }, 
        {
            "location": "/Observable/#observableprototypebuffer", 
            "text": "(maxLastValues: number = 0): Observable T[]  Creates a derivative stream of parent  Observable  values gathered in array.\nNew values set is released after\nall other  Observable s values are pushed through\nand all  Domain  actions being called.\nYou can specify how many of there messages has to be remembered.", 
            "title": "Observable.prototype.buffer"
        }, 
        {
            "location": "/Observable/#observableprototypebuffercount", 
            "text": "(bufferSize: number, customBufferCount: number = null): Observable T[]  Creates a derivative stream containing parent  Observable  values\ngathered in an Array.\nNew values set is released\nevery  bufferSize -th parent  Observable  value or\nevery  customBufferCount -th parent  Observable  value\nif second argument is present.  As it might be still mysterious how it works\nconsider these graphical representations\nof how values are pushed in time:  const a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(2)\n\na --1--2--3--4--5--|\nb -----[1,2]-[3,4]-[5]|  const a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(3, 2) // now with custom window\n\na --1--2--3-------4--5-|\nb --------[1,2,3]----[3,4,5]-|", 
            "title": "Observable.prototype.bufferCount"
        }, 
        {
            "location": "/Observable/#observableprototypereemit", 
            "text": "(): Observable T  Creates a derivative stream where all values pushed by source are pushed by this node too,\nbut also this new one will push at first last value that has been pushed by source in the past,\nif any was actually pushed.  async function example() {\n    const a = new Observable().startWith(1)\n    await leThreeHoursLater()\n    const b = a.reemit()\n    console.log(await b.toPromise()) // logs '1'\n}", 
            "title": "Observable.prototype.reemit"
        }, 
        {
            "location": "/Combine/", 
            "text": "class Combine\nT\n extends \nObservable\nT\n\n\n( { [name: string]: Observable } ): Observable\n\n\nResponsible for being reactive to more than one source and placing source streams contents in their respective (according to informations provided upon initialization) field in result object.\n\n\nconst join = new Combine({\n    a: new Observable(observer =\n { observer.next('a') }),\n    b: new Observable(observer =\n { observer.next('b') })\n})\njoin.subscribe(v =\n {\n    console.log(v) // {a: 'a', b: 'b'}\n})", 
            "title": "Combine"
        }, 
        {
            "location": "/Combine/#class-combinet-extends-observablet", 
            "text": "( { [name: string]: Observable } ): Observable  Responsible for being reactive to more than one source and placing source streams contents in their respective (according to informations provided upon initialization) field in result object.  const join = new Combine({\n    a: new Observable(observer =  { observer.next('a') }),\n    b: new Observable(observer =  { observer.next('b') })\n})\njoin.subscribe(v =  {\n    console.log(v) // {a: 'a', b: 'b'}\n})", 
            "title": "class Combine&lt;T&gt; extends Observable&lt;T&gt;"
        }, 
        {
            "location": "/Domain/", 
            "text": "class Domain\nT\n extends \nObservable\nT\n\n\n( source: Observable\nT\n )\n\n\nClass constructor alone will be only helpful when extending \nDomain\n class.\n\n\n\n\nDomain.create\n\n\n( name?: string, source?: observable\nT\n, actions: { [name: string]: () =\n promise\nlt;any\ngt; | void }, fields?: {}) =\n Domain\n\n\nDomain\n class by design is the only thing that should be exported and used (maybe with an exception of type definitions) outside of \nDomain\ns scope.\nFor example: if you have a folder like:\n\n\n\u2514 SomeDomain\n  \u251c index.js // here is Domain creation\n  \u251c SomeDomainState.js // downstream - source observables or stream transformations\n  \u2514 SomeDomainActions.js // functions to manipulate `Domain`'s state\n\n\n\n\nyou should export SomeDomain from index.js and use only that in any other file.\n\n\nFirst argument of the factory function is an observable emiting messages that will be emited by the \nDomain\n's instance too.\nOnly single data source can be tied to a \nDomain\n, but you can always use \nCombine\n to combine multiple streams.\n\n\nSecond argument is an object aggregating functions used to create actions and other values that will be exposed as part of the \nDomain\n interface.\nProvided functions will be wrapped with an internal Dispatcher calls. That mechanism ensures that they will always be executed one \nafter\n another. That is a design decision which makes it easier to reason about what is happening inside application.\nFunctions provided as \nDomain\n \nactions\n must not return any value.\nCalling an action however will return a Promise resolved after action function execution.\n\n\n// example usage\nimport {Combine, Domain} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = Domain.create(\n    new Combine({\n        HorizonDomain,\n        MusclesDomain,\n    }),\n    {\n        roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    },\n    {\n        EXTRAOCULAR_MUSCLES: 6\n    }\n)\n\nEyesDomain.roll().then(() =\n { console.log('I saw that!') })\nEyesDomain.EXTRAOCULAR_MUSCLES // 6\n\n\n\n\n\n\nDomain.tagged\n\n\nname\n =\n \n( source: observable\nT\n , actions: { [name: string]: () =\n promise\nlt;any\ngt; | void }, fields: {}) =\n Domain\n\n\nBasically the same as \nDomain.create\n,\nbut it returns a function that receives same arguments as \nDomain.create\n,\nthat creates \nDomain\n using name provided with tagged template string literal.\n\n\nHelpful for debugging purposes.\n\n\nimport {Domain} from 'immview'\nDomain.tagged`Yolo`(new Observable(observer =\n { observer.next('once')}), {})\n````\n\n---\n## *DomainInstance*.[ACTION_NAME]\n`(...args): Promise`\n\nA function that was in a provided in constructor set of actions.\nIt is **not** exactly the same function as provided, because it is wrapped with internal scheduler call.\nBecause it's deferred execution **it always returns a Promise** resolved with that function result.\n\n```javascript\nconst domain = Domain.create(\n    new Observable(observer =\n { ... }),\n    { foo: () =\n console.log('bar') }\n)\ndomain.foo()\n// prints: 'bar'", 
            "title": "Domain"
        }, 
        {
            "location": "/Domain/#class-domaint-extends-observablet", 
            "text": "( source: Observable T  )  Class constructor alone will be only helpful when extending  Domain  class.", 
            "title": "class Domain&lt;T&gt; extends Observable&lt;T&gt;"
        }, 
        {
            "location": "/Domain/#domaincreate", 
            "text": "( name?: string, source?: observable T , actions: { [name: string]: () =  promise lt;any gt; | void }, fields?: {}) =  Domain  Domain  class by design is the only thing that should be exported and used (maybe with an exception of type definitions) outside of  Domain s scope.\nFor example: if you have a folder like:  \u2514 SomeDomain\n  \u251c index.js // here is Domain creation\n  \u251c SomeDomainState.js // downstream - source observables or stream transformations\n  \u2514 SomeDomainActions.js // functions to manipulate `Domain`'s state  you should export SomeDomain from index.js and use only that in any other file.  First argument of the factory function is an observable emiting messages that will be emited by the  Domain 's instance too.\nOnly single data source can be tied to a  Domain , but you can always use  Combine  to combine multiple streams.  Second argument is an object aggregating functions used to create actions and other values that will be exposed as part of the  Domain  interface.\nProvided functions will be wrapped with an internal Dispatcher calls. That mechanism ensures that they will always be executed one  after  another. That is a design decision which makes it easier to reason about what is happening inside application.\nFunctions provided as  Domain   actions  must not return any value.\nCalling an action however will return a Promise resolved after action function execution.  // example usage\nimport {Combine, Domain} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = Domain.create(\n    new Combine({\n        HorizonDomain,\n        MusclesDomain,\n    }),\n    {\n        roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    },\n    {\n        EXTRAOCULAR_MUSCLES: 6\n    }\n)\n\nEyesDomain.roll().then(() =  { console.log('I saw that!') })\nEyesDomain.EXTRAOCULAR_MUSCLES // 6", 
            "title": "Domain.create"
        }, 
        {
            "location": "/Domain/#domaintagged", 
            "text": "name  =   ( source: observable T  , actions: { [name: string]: () =  promise lt;any gt; | void }, fields: {}) =  Domain  Basically the same as  Domain.create ,\nbut it returns a function that receives same arguments as  Domain.create ,\nthat creates  Domain  using name provided with tagged template string literal.  Helpful for debugging purposes.  import {Domain} from 'immview'\nDomain.tagged`Yolo`(new Observable(observer =  { observer.next('once')}), {})\n````\n\n---\n## *DomainInstance*.[ACTION_NAME]\n`(...args): Promise`\n\nA function that was in a provided in constructor set of actions.\nIt is **not** exactly the same function as provided, because it is wrapped with internal scheduler call.\nBecause it's deferred execution **it always returns a Promise** resolved with that function result.\n\n```javascript\nconst domain = Domain.create(\n    new Observable(observer =  { ... }),\n    { foo: () =  console.log('bar') }\n)\ndomain.foo()\n// prints: 'bar'", 
            "title": "Domain.tagged"
        }
    ]
}