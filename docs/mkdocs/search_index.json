{
    "docs": [
        {
            "location": "/", 
            "text": "Immview\n is a library to create \nDomain\ns - \nnon-visual components\n -\nsimilar to flux stores, exposing their \nstate\n (through \nAtom\ns) or emitting \nsignals\n\n(through \nObservable\ns) and having specific to their concerns \nactions\n.\nTheir primary role is to encapsulate a concern\nand to be the only thing exported from a javascript module or modules\nthat deal with the concern.\n\n\nIt completely replaces any flux implementation or Redux, although surely could be integrated with one easily.\n\n\nAll \nDomain\ns must be provided with a single stream of values\n(\nAtom\n or \nObservable\n class instance),\nbut not all \nObservable\ns and \nAtom\ns must be attached to a \nDomain\n -\nyou can perform many transformations on a source\nbefore it is exposed through a \nDomain\n.\nThese transformations are done with operators -\nfunctions that exist on these classes prototypes.\n\n\nExample\n\n\nimport { Atom, Domain } from 'immview'\n\nconst toDoList$ = new Atom([])\n\nconst toDoActions = {\n  add(label) {\n    toDoList$.next(\n      todos =\n [\n        { label, done: false },\n        ...todos\n      ]\n    )\n  },\n\n  check(index) {\n    toDoList$.next(\n      todos =\n todos.map(\n          (todo, i) =\n (\n              i === index\n                ? { label: todo.label, done: true }\n                : todo\n          )\n      )\n    )\n  },\n\n  remove(index) {\n    toDoList$.next(\n      todos =\n todos.filter((_, i) =\n i !== index)\n    )\n  }\n}\n\nconst ToDo$ = Domain.create(\n  toDoList$,\n  toDoActions\n)\n\nToDo$.subscribe(v =\n console.log(JSON.stringify(v)))\n// console: []\n\nToDo$.add('Eat a pizza')\n// console: [{ label: \nEat a pizza\n, done: false }]\n\nToDo$.check(0)\n// console: [{ label: \nEat a pizza\n, done: true }]\n\n\n\n\nDemo\n\n\n\n\nsee above live on https://runkit.com/arturkulig/immview-todo-example\n\n\n\n\nReact\n\n\nIf you are using React to create presentation layer of your app you should check \nimmview-react-connect", 
            "title": "Immview"
        }, 
        {
            "location": "/#example", 
            "text": "import { Atom, Domain } from 'immview'\n\nconst toDoList$ = new Atom([])\n\nconst toDoActions = {\n  add(label) {\n    toDoList$.next(\n      todos =  [\n        { label, done: false },\n        ...todos\n      ]\n    )\n  },\n\n  check(index) {\n    toDoList$.next(\n      todos =  todos.map(\n          (todo, i) =  (\n              i === index\n                ? { label: todo.label, done: true }\n                : todo\n          )\n      )\n    )\n  },\n\n  remove(index) {\n    toDoList$.next(\n      todos =  todos.filter((_, i) =  i !== index)\n    )\n  }\n}\n\nconst ToDo$ = Domain.create(\n  toDoList$,\n  toDoActions\n)\n\nToDo$.subscribe(v =  console.log(JSON.stringify(v)))\n// console: []\n\nToDo$.add('Eat a pizza')\n// console: [{ label:  Eat a pizza , done: false }]\n\nToDo$.check(0)\n// console: [{ label:  Eat a pizza , done: true }]", 
            "title": "Example"
        }, 
        {
            "location": "/#demo", 
            "text": "see above live on https://runkit.com/arturkulig/immview-todo-example", 
            "title": "Demo"
        }, 
        {
            "location": "/#react", 
            "text": "If you are using React to create presentation layer of your app you should check  immview-react-connect", 
            "title": "React"
        }, 
        {
            "location": "/Observable/", 
            "text": "class \nObservable\nT\n\n\nnew (subscriber: (observer: {next: (value: T) =\n void, error: (err: Error) =\n void, complete: () =\n void}) =\n void | () =\n void)\n\n\nConstruct with \nsubscriber\n function that receives \nobserver\n object. \nObserver\n is for pushing values, errors and completion signal.\n\n\nSubscriber\n function may return function that should be called if \nObservable\n receives \ncomplete\n signal or is cancelled.\n\n\n\n\nstatic \nof\n\n\n(...args: T[]): Observable\nT\n;\n\n\nFunction to create an \nObservable\n that immediately pushes values given as arguments.\n\n\nStream is immediately completed after all values are pushed.\n\nIf you wish to create a stream and kickstart it with a value(s), use \nstartWith\n.\n\n\n\n\nstatic \nfrom\n\n\n(values: T[]): Observable\nT\n;\n\n\nFunction to create an \nObservable\n that immediately pushes values given as an array of values.\n\n\nStream is immediately completed after all values are pushed.\n\nIf you wish to create a stream and kickstart it with a value(s), use \nstartWith\n.\n\n\n\n\nstatic \nfromPromise\n\n\n(values: Promise\nT\n): Observable\nT\n;\n\n\nFunction to create an \nObservable\n that pushes a value\nrevealed with provided \nPromise\n and then completes\nas no more values to get from it.\n\n\nSubscribable interface\n\n\n\n\nsubscribe\n\n\n( { start: (sub: Subscription) =\n void, next: (value: T) =\n void, error: (err: Error) =\n void, complete: () =\n void } ) =\n { unsubscribe(): void }\n\n\n( onNext?: (value: T) =\n void, onError?: (err: Error) =\n void, onCompletion?: () =\n void ) =\n { unsubscribe(): void }\n\n\nRegisters a function called every time when the Observable changes value that it holds, error is pushed or Observable is complete.\n\n\nReturns a function to unregister the subscription.\n\n\n\n\ntoPromise\n\n\n() =\n T\n\n\nReturns next \nvalue\n that's going to be pushed through the \nObservable\n instance.\n\n\n// Example\nconst source = new Observable()\nsetTimeout(() =\n source.next(1), 100)\nconst value = await source.toPromise()\n\n\n\n\n\n\nprevious\n\n\nDEPRECATED - use deref and hasRef\n\n\n() =\n T | NO_VALUE\n\n\nReturns previous \nvalue\n that has been pushed through the \nObservable\n instance.\nIf no value has been pushed yet, NO_VALUE object is released.\n\n\nimport {Observable, NO_VALUE} from 'immview'\n// Example\nconst source = new Observable(({next}) =\n { next(1) })\nsource.previous() === NO_VALUE // true\nsource.subscribe(value =\n {\n    value === source.previous() // true\n})\n\n\n\n\nObserver interface\n\n\n\n\nnext\n\n\n(nextValue: T) =\n void\n\n\nSends value signal through the \nObservable\n instance. Values can be received, by \nObservable.prototype.subscribe\n method or \nObservable.prototype.previous\n.\n\n\n\n\nerror\n\n\n(error: Error) =\n void\n\n\nSends error signal through the \nObservable\n instance. Errors can be received, with \nObservable.prototype.subscribe\n method.\n\n\n\n\ncomplete\n\n\n() =\n void\n\n\nSends \ncomplete\n signal through the \nObservable\n instance. Completion can be handled, with \nObservable.prototype.subscribe\n method.\n\n\nOperators - common\n\n\n\n\nmap\n\n\n(action: (value: T) =\n U): Observable\nU\n\n\nCreates a derivative stream of values where\nevery value pushed by a parent is transformed with \naction\n function and push further by \nObservable\n -\nresult of this function call.\n\n\n\n\nfilter\n\n\n(filter: (value: T) =\n boolean): Observable\nT\n;\n\n\nCreates a derivative stream of values where\nonly those values that meet requirements formulated\nwith \nfilter\n function are going to be pushed by that derivative \nObservable\n.\n\n\n\n\nscan\n\n\n(accumulator: (summary: U, value: T, index: number) =\n U, defaultValue?: U): Observable\nU\n\n\nCreates a derivative stream of values where\non every value that parent pushes\nthere is \naccumulator\n function called\ngetting last pushed value and new value that has been pushed by parent \nObservable\n.\nResult of the function is next value of newly created \nObservable\n.\nFirst call is with summary being undefined unless \ndefautValue\n is also passed.\n\n\n\n\nflatten\n\n\n(): Observable\nU\n\n\nWhen parent \nObservable\n is releasing other \nObservable\ns as values\nuse \nflatten\n to create a derivative stream that consists only of values\nthat are released by these \"observable values\".\n\n\n\n\nmerge\n\n\n`(...args: Observable\n;[]): Observable\n;\n\n\nCreates a stream containing all values of parent and of provided in arguments streams.\n\n\n\n\ndistinct\n\n\n(comparator?: (prev: T, next: T) =\n boolean): Observable\nT\n;\n\n\nCreates a derivative stream of values\nbut eliminates repeated subsequent value occurences.\n\n\nIf \ncomparator\n is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.\n\n\n\n\nbuffer\n\n\n(maxLastValues: number = 0): Observable\nT[]\n\n\nCreates a derivative stream of parent \nObservable\n values gathered in array.\nNew values set is released after\nall other \nObservable\ns values are pushed through\nand all \nDomain\n actions being called.\nYou can specify how many of there messages has to be remembered.\n\n\n\n\nmaterialize\n\n\n(defaultState: T): Atom\nT\n\n\nCreates a derivative stream with an \nAtom\n where all values pushed by source are pushed by this node too.\nResulting \nAtom\n will start with \ndefaultState\n state value.\n\n\nasync function example() {\n    const a = new Observable().materialize(1)\n    await leThreeHoursLater()\n    console.log(a.deref()) // logs '1'\n}\n\n\n\n\nOperators - specific\n\n\n\n\nstartWith\n\n\n(firstValue: T): Observable\nT\n;\n\n\nCreates a derivative stream of values where\nit has all values of parent stream, but these are preceeded\nwith \nfirstValue\n that is immediately shared with all other nodes\nthat subscribed to the newly created stream.\n\n\n\n\nbufferCount\n\n\n(bufferSize: number, customBufferCount: number = null): Observable\nT[]\n\n\nCreates a derivative stream containing parent \nObservable\n values\ngathered in an Array.\nNew values set is released\nevery \nbufferSize\n-th parent \nObservable\n value or\nevery \ncustomBufferCount\n-th parent \nObservable\n value\nif second argument is present.\n\n\nAs it might be still mysterious how it works\nconsider these graphical representations\nof how values are pushed in time:\n\n\nconst a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(2)\n\na --1--2--3--4--5--|\nb -----[1,2]-[3,4]-[5]|\n\n\n\n\nconst a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(3, 2) // now with custom window\n\na --1--2--3-------4--5-|\nb --------[1,2,3]----[3,4,5]-|\n\n\n\n\n\n\nreemit\n\n\n(): Observable\nT\n\n\nCreates a derivative stream where all values pushed by source are pushed by this node too,\nbut also this new one will push at first last value that has been pushed by source in the past,\nif any was actually pushed.\n\n\nasync function example() {\n    const a = new Observable().startWith(1)\n    await leThreeHoursLater()\n    const b = a.reemit()\n    console.log(await b.toPromise()) // logs '1'\n}", 
            "title": "Observable"
        }, 
        {
            "location": "/Observable/#class-observablet", 
            "text": "new (subscriber: (observer: {next: (value: T) =  void, error: (err: Error) =  void, complete: () =  void}) =  void | () =  void)  Construct with  subscriber  function that receives  observer  object.  Observer  is for pushing values, errors and completion signal.  Subscriber  function may return function that should be called if  Observable  receives  complete  signal or is cancelled.", 
            "title": "class Observable&lt;T&gt;"
        }, 
        {
            "location": "/Observable/#static-of", 
            "text": "(...args: T[]): Observable T ;  Function to create an  Observable  that immediately pushes values given as arguments.  Stream is immediately completed after all values are pushed. \nIf you wish to create a stream and kickstart it with a value(s), use  startWith .", 
            "title": "static of"
        }, 
        {
            "location": "/Observable/#static-from", 
            "text": "(values: T[]): Observable T ;  Function to create an  Observable  that immediately pushes values given as an array of values.  Stream is immediately completed after all values are pushed. \nIf you wish to create a stream and kickstart it with a value(s), use  startWith .", 
            "title": "static from"
        }, 
        {
            "location": "/Observable/#static-frompromise", 
            "text": "(values: Promise T ): Observable T ;  Function to create an  Observable  that pushes a value\nrevealed with provided  Promise  and then completes\nas no more values to get from it.", 
            "title": "static fromPromise"
        }, 
        {
            "location": "/Observable/#subscribable-interface", 
            "text": "", 
            "title": "Subscribable interface"
        }, 
        {
            "location": "/Observable/#subscribe", 
            "text": "( { start: (sub: Subscription) =  void, next: (value: T) =  void, error: (err: Error) =  void, complete: () =  void } ) =  { unsubscribe(): void }  ( onNext?: (value: T) =  void, onError?: (err: Error) =  void, onCompletion?: () =  void ) =  { unsubscribe(): void }  Registers a function called every time when the Observable changes value that it holds, error is pushed or Observable is complete.  Returns a function to unregister the subscription.", 
            "title": "subscribe"
        }, 
        {
            "location": "/Observable/#topromise", 
            "text": "() =  T  Returns next  value  that's going to be pushed through the  Observable  instance.  // Example\nconst source = new Observable()\nsetTimeout(() =  source.next(1), 100)\nconst value = await source.toPromise()", 
            "title": "toPromise"
        }, 
        {
            "location": "/Observable/#previous", 
            "text": "", 
            "title": "previous"
        }, 
        {
            "location": "/Observable/#deprecated-use-deref-and-hasref", 
            "text": "() =  T | NO_VALUE  Returns previous  value  that has been pushed through the  Observable  instance.\nIf no value has been pushed yet, NO_VALUE object is released.  import {Observable, NO_VALUE} from 'immview'\n// Example\nconst source = new Observable(({next}) =  { next(1) })\nsource.previous() === NO_VALUE // true\nsource.subscribe(value =  {\n    value === source.previous() // true\n})", 
            "title": "DEPRECATED - use deref and hasRef"
        }, 
        {
            "location": "/Observable/#observer-interface", 
            "text": "", 
            "title": "Observer interface"
        }, 
        {
            "location": "/Observable/#next", 
            "text": "(nextValue: T) =  void  Sends value signal through the  Observable  instance. Values can be received, by  Observable.prototype.subscribe  method or  Observable.prototype.previous .", 
            "title": "next"
        }, 
        {
            "location": "/Observable/#error", 
            "text": "(error: Error) =  void  Sends error signal through the  Observable  instance. Errors can be received, with  Observable.prototype.subscribe  method.", 
            "title": "error"
        }, 
        {
            "location": "/Observable/#complete", 
            "text": "() =  void  Sends  complete  signal through the  Observable  instance. Completion can be handled, with  Observable.prototype.subscribe  method.", 
            "title": "complete"
        }, 
        {
            "location": "/Observable/#operators-common", 
            "text": "", 
            "title": "Operators - common"
        }, 
        {
            "location": "/Observable/#map", 
            "text": "(action: (value: T) =  U): Observable U  Creates a derivative stream of values where\nevery value pushed by a parent is transformed with  action  function and push further by  Observable  -\nresult of this function call.", 
            "title": "map"
        }, 
        {
            "location": "/Observable/#filter", 
            "text": "(filter: (value: T) =  boolean): Observable T ;  Creates a derivative stream of values where\nonly those values that meet requirements formulated\nwith  filter  function are going to be pushed by that derivative  Observable .", 
            "title": "filter"
        }, 
        {
            "location": "/Observable/#scan", 
            "text": "(accumulator: (summary: U, value: T, index: number) =  U, defaultValue?: U): Observable U  Creates a derivative stream of values where\non every value that parent pushes\nthere is  accumulator  function called\ngetting last pushed value and new value that has been pushed by parent  Observable .\nResult of the function is next value of newly created  Observable .\nFirst call is with summary being undefined unless  defautValue  is also passed.", 
            "title": "scan"
        }, 
        {
            "location": "/Observable/#flatten", 
            "text": "(): Observable U  When parent  Observable  is releasing other  Observable s as values\nuse  flatten  to create a derivative stream that consists only of values\nthat are released by these \"observable values\".", 
            "title": "flatten"
        }, 
        {
            "location": "/Observable/#merge", 
            "text": "`(...args: Observable ;[]): Observable ;  Creates a stream containing all values of parent and of provided in arguments streams.", 
            "title": "merge"
        }, 
        {
            "location": "/Observable/#distinct", 
            "text": "(comparator?: (prev: T, next: T) =  boolean): Observable T ;  Creates a derivative stream of values\nbut eliminates repeated subsequent value occurences.  If  comparator  is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.", 
            "title": "distinct"
        }, 
        {
            "location": "/Observable/#buffer", 
            "text": "(maxLastValues: number = 0): Observable T[]  Creates a derivative stream of parent  Observable  values gathered in array.\nNew values set is released after\nall other  Observable s values are pushed through\nand all  Domain  actions being called.\nYou can specify how many of there messages has to be remembered.", 
            "title": "buffer"
        }, 
        {
            "location": "/Observable/#materialize", 
            "text": "(defaultState: T): Atom T  Creates a derivative stream with an  Atom  where all values pushed by source are pushed by this node too.\nResulting  Atom  will start with  defaultState  state value.  async function example() {\n    const a = new Observable().materialize(1)\n    await leThreeHoursLater()\n    console.log(a.deref()) // logs '1'\n}", 
            "title": "materialize"
        }, 
        {
            "location": "/Observable/#operators-specific", 
            "text": "", 
            "title": "Operators - specific"
        }, 
        {
            "location": "/Observable/#startwith", 
            "text": "(firstValue: T): Observable T ;  Creates a derivative stream of values where\nit has all values of parent stream, but these are preceeded\nwith  firstValue  that is immediately shared with all other nodes\nthat subscribed to the newly created stream.", 
            "title": "startWith"
        }, 
        {
            "location": "/Observable/#buffercount", 
            "text": "(bufferSize: number, customBufferCount: number = null): Observable T[]  Creates a derivative stream containing parent  Observable  values\ngathered in an Array.\nNew values set is released\nevery  bufferSize -th parent  Observable  value or\nevery  customBufferCount -th parent  Observable  value\nif second argument is present.  As it might be still mysterious how it works\nconsider these graphical representations\nof how values are pushed in time:  const a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(2)\n\na --1--2--3--4--5--|\nb -----[1,2]-[3,4]-[5]|  const a = Observable.of(1, 2, 3, 4, 5)\nconst b = a.bufferCount(3, 2) // now with custom window\n\na --1--2--3-------4--5-|\nb --------[1,2,3]----[3,4,5]-|", 
            "title": "bufferCount"
        }, 
        {
            "location": "/Observable/#reemit", 
            "text": "(): Observable T  Creates a derivative stream where all values pushed by source are pushed by this node too,\nbut also this new one will push at first last value that has been pushed by source in the past,\nif any was actually pushed.  async function example() {\n    const a = new Observable().startWith(1)\n    await leThreeHoursLater()\n    const b = a.reemit()\n    console.log(await b.toPromise()) // logs '1'\n}", 
            "title": "reemit"
        }, 
        {
            "location": "/Atom/", 
            "text": "class \nAtom\nT\n\n\nnew (initialState: T)\n\n\nInstantiate an \nAtom\n with it's default state.\n\n\n\n\nstatic \nof\n\n\n(...args: T[]): Atom\nT\n;\n\n\nFunction to create an \nAtom\n that's state set to last given argument.\n\n\nconst a = Atom.of(1, 2, 3)\nconsole.log(a.deref()) // 3\n\n\n\n\nStream is immediately completed after all values are pushed.\n\n\n\n\nstatic \nfrom\n\n\n(values: T[]): Atom\nT\n;\n\n\nFunction to create an \nAtom\n that's state set to last value of an \nIterable\n.\nGiven other \nAtom\n, copies it's state.\n\n\nStream is immediately completed after all values are pushed.\n\n\nSubscribable interface\n\n\n\n\nsubscribe\n\n\n( { start: (sub: Subscription) =\n void, next: (value: T) =\n void, error: (err: Error) =\n void, complete: () =\n void } ) =\n { unsubscribe(): void }\n\n\n( onNext?: (value: T) =\n void, onError?: (err: Error) =\n void, onCompletion?: () =\n void ) =\n { unsubscribe(): void }\n\n\nRegisters a function called every time when the \nAtom\n changes value that it holds, error is pushed or \nAtom\n is complete.\n\n\nReturns a function to unregister the subscription.\n\n\n\n\ntoPromise\n\n\n() =\n T\n\n\nReturns next \nvalue\n that's going to be pushed through the \nAtom\n instance.\n\n\n// Example\nconst source = new Atom()\nsetTimeout(() =\n source.next(1), 100)\nconst value = await source.toPromise()\n\n\n\n\nObserver interface\n\n\n\n\nnext\n\n\n(nextValue: T) =\n void\n\n\nSends value signal through the \nAtom\n instance. Values can be received, by \nAtom.prototype.subscribe\n method or \nAtom.prototype.previous\n.\n\n\n\n\nerror\n\n\n(error: Error) =\n void\n\n\nSends error signal through the \nAtom\n instance. Errors can be received, with \nAtom.prototype.subscribe\n method.\n\n\n\n\ncomplete\n\n\n() =\n void\n\n\nSends \ncomplete\n signal through the \nAtom\n instance. Completion can be handled, with \nAtom.prototype.subscribe\n method.\n\n\nOperators - common\n\n\n\n\nmap\n\n\n(action: (value: T) =\n U): Atom\nU\n\n\nCreates a derivative stream of values where\nevery value pushed by a parent is transformed with \naction\n function and push further by \nAtom\n -\nresult of this function call.\n\n\n\n\nfilter\n\n\n(filter: (value: T) =\n boolean): Atom\nT\n;\n\n\nCreates a derivative stream of values where\nonly those values that meet requirements formulated\nwith \nfilter\n function are going to be pushed by that derivative \nAtom\n.\n\n\nFirst value of \nAtom\n is not validated by provided function\n\n\n\n\nscan\n\n\n(accumulator: (summary: U, value: T, index: number) =\n U, defaultValue?: U): Atom\nU\n\n\nCreates a derivative stream of values where\non every value that parent pushes\nthere is \naccumulator\n function called\ngetting last pushed value and new value that has been pushed by parent \nAtom\n.\nResult of the function is next value of newly created \nAtom\n.\nFirst call is with summary being undefined unless \ndefautValue\n is also passed.\n\n\n\n\nflatten\n\n\n(): Atom\nU\n\n\nWhen parent \nAtom\n is releasing other \nAtom\ns as values\nuse \nflatten\n to create a derivative stream that consists only of values\nthat are released by these \"Atom values\".\n\n\n\n\nmerge\n\n\n`(...args: Atom\n;[]): Atom\n;\n\n\nCreates a stream containing all values of parent and of provided in arguments streams.\n\n\n\n\ndistinct\n\n\n(comparator?: (prev: T, next: T) =\n boolean): Atom\nT\n;\n\n\nCreates a derivative stream of values\nbut eliminates repeated subsequent value occurences.\n\n\nIf \ncomparator\n is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.\n\n\n\n\nbuffer\n\n\n(maxLastValues: number = 0): Atom\nT[]\n\n\nCreates a derivative stream of parent \nAtom\n values gathered in array.\nNew values set is released after\nall other \nAtom\ns values are pushed through\nand all \nDomain\n actions being called.\nYou can specify how many of there messages has to be remembered.\n\n\n\n\nmaterialize\n\n\n(defaultState: T): Atom\nT\n\n\nReturns itself.", 
            "title": "Atom"
        }, 
        {
            "location": "/Atom/#class-atomt", 
            "text": "new (initialState: T)  Instantiate an  Atom  with it's default state.", 
            "title": "class Atom&lt;T&gt;"
        }, 
        {
            "location": "/Atom/#static-of", 
            "text": "(...args: T[]): Atom T ;  Function to create an  Atom  that's state set to last given argument.  const a = Atom.of(1, 2, 3)\nconsole.log(a.deref()) // 3  Stream is immediately completed after all values are pushed.", 
            "title": "static of"
        }, 
        {
            "location": "/Atom/#static-from", 
            "text": "(values: T[]): Atom T ;  Function to create an  Atom  that's state set to last value of an  Iterable .\nGiven other  Atom , copies it's state.  Stream is immediately completed after all values are pushed.", 
            "title": "static from"
        }, 
        {
            "location": "/Atom/#subscribable-interface", 
            "text": "", 
            "title": "Subscribable interface"
        }, 
        {
            "location": "/Atom/#subscribe", 
            "text": "( { start: (sub: Subscription) =  void, next: (value: T) =  void, error: (err: Error) =  void, complete: () =  void } ) =  { unsubscribe(): void }  ( onNext?: (value: T) =  void, onError?: (err: Error) =  void, onCompletion?: () =  void ) =  { unsubscribe(): void }  Registers a function called every time when the  Atom  changes value that it holds, error is pushed or  Atom  is complete.  Returns a function to unregister the subscription.", 
            "title": "subscribe"
        }, 
        {
            "location": "/Atom/#topromise", 
            "text": "() =  T  Returns next  value  that's going to be pushed through the  Atom  instance.  // Example\nconst source = new Atom()\nsetTimeout(() =  source.next(1), 100)\nconst value = await source.toPromise()", 
            "title": "toPromise"
        }, 
        {
            "location": "/Atom/#observer-interface", 
            "text": "", 
            "title": "Observer interface"
        }, 
        {
            "location": "/Atom/#next", 
            "text": "(nextValue: T) =  void  Sends value signal through the  Atom  instance. Values can be received, by  Atom.prototype.subscribe  method or  Atom.prototype.previous .", 
            "title": "next"
        }, 
        {
            "location": "/Atom/#error", 
            "text": "(error: Error) =  void  Sends error signal through the  Atom  instance. Errors can be received, with  Atom.prototype.subscribe  method.", 
            "title": "error"
        }, 
        {
            "location": "/Atom/#complete", 
            "text": "() =  void  Sends  complete  signal through the  Atom  instance. Completion can be handled, with  Atom.prototype.subscribe  method.", 
            "title": "complete"
        }, 
        {
            "location": "/Atom/#operators-common", 
            "text": "", 
            "title": "Operators - common"
        }, 
        {
            "location": "/Atom/#map", 
            "text": "(action: (value: T) =  U): Atom U  Creates a derivative stream of values where\nevery value pushed by a parent is transformed with  action  function and push further by  Atom  -\nresult of this function call.", 
            "title": "map"
        }, 
        {
            "location": "/Atom/#filter", 
            "text": "(filter: (value: T) =  boolean): Atom T ;  Creates a derivative stream of values where\nonly those values that meet requirements formulated\nwith  filter  function are going to be pushed by that derivative  Atom .  First value of  Atom  is not validated by provided function", 
            "title": "filter"
        }, 
        {
            "location": "/Atom/#scan", 
            "text": "(accumulator: (summary: U, value: T, index: number) =  U, defaultValue?: U): Atom U  Creates a derivative stream of values where\non every value that parent pushes\nthere is  accumulator  function called\ngetting last pushed value and new value that has been pushed by parent  Atom .\nResult of the function is next value of newly created  Atom .\nFirst call is with summary being undefined unless  defautValue  is also passed.", 
            "title": "scan"
        }, 
        {
            "location": "/Atom/#flatten", 
            "text": "(): Atom U  When parent  Atom  is releasing other  Atom s as values\nuse  flatten  to create a derivative stream that consists only of values\nthat are released by these \"Atom values\".", 
            "title": "flatten"
        }, 
        {
            "location": "/Atom/#merge", 
            "text": "`(...args: Atom ;[]): Atom ;  Creates a stream containing all values of parent and of provided in arguments streams.", 
            "title": "merge"
        }, 
        {
            "location": "/Atom/#distinct", 
            "text": "(comparator?: (prev: T, next: T) =  boolean): Atom T ;  Creates a derivative stream of values\nbut eliminates repeated subsequent value occurences.  If  comparator  is passed, it is going to be used\nto determine if a value is distinct from previous one.\nOtherwise strict equal is incorporated.", 
            "title": "distinct"
        }, 
        {
            "location": "/Atom/#buffer", 
            "text": "(maxLastValues: number = 0): Atom T[]  Creates a derivative stream of parent  Atom  values gathered in array.\nNew values set is released after\nall other  Atom s values are pushed through\nand all  Domain  actions being called.\nYou can specify how many of there messages has to be remembered.", 
            "title": "buffer"
        }, 
        {
            "location": "/Atom/#materialize", 
            "text": "(defaultState: T): Atom T  Returns itself.", 
            "title": "materialize"
        }, 
        {
            "location": "/AtomObservableDiff/", 
            "text": "What's the difference between \nAtom\n and \nObservable\n classes?\n\n\nBoth \nAtom\n and \nObservable\n look very similar at first glance,\nbut they really have very different purpose.\n\n\nAtom\n is encapsulated observable state value.\n\n\nObservable\n is encapsulated stream of messages, \nthat is: values that are relevant only at time of their publishing.\n\n\nLet's have this as an example:\n\n\nimport {Atom, Observable} from \nimmview\n\n\nconst a$ = new Atom('-')\na$.next('first')\na$.next('second')\na$.subscribe(v =\n console.log(`A  ${v}`))\n    // logs: A  second\na$.subscribe(v =\n console.log(`A2 ${v}`))\n    // logs: A2 second\na$.next('third')\n    // logs: A  third\n    // logs: A2 third\n\nconst o$ = new Observable(({next}) =\n {next('-')})\no$.next('first')\no$.next('second')\no$.subscribe(v =\n console.log(`O  ${v}`))\n    // logs: O  -\n    // logs: O  first\n    // logs: O  second\no$.subscribe(v =\n console.log(`O2 ${v}`))\no$.next('third')\n    // logs: O  third\n    // logs: O2 third\n\nlog.join('\\n')\n\n\n\n\n\n\nsee that running live on https://runkit.com/arturkulig/immview-atom-observable-difference\n\n\n\n\nAs you can see first few values pushed through the \na$ (Atom)\n \nare lost\n.\nThis is because these previous values are not that \nAtom\n's state anymore. It will allow reading it's value to every subscriber and will notify these subscribers if state changes, but it is not a message queue, so previous states are not relevant.\n\n\nObservable\n on the other hand is just \na message queue\n. No message is lost and all queued messages are dispatched to subscribers as soon as possible. You can make sure that all subscriptions are created by the time first value is pushed, so all of them are notified of all messages, but that is up to a library user, it might not be important after all.\n\n\nWhere to use which?\n\n\nDifferent nature of both of these streaming primitives may be still unclear? More real-life example might be of use.\n\n\nConsider connectivity through HTTP tooling prepared with \nImmview\n. In case you want to broadcast structures that inform about fetching status of different resources you'd use an \nObservable\n, but if you wish to maintain a registry of requesting and finally - content of  every requested remote resource - you'd prefer an \nAtom\n for the job.\n\n\nYou might as well have both! First an \nObservable\n that just broadcasts requests status and then an \nAtom\n (might be even in different \nDomain\n) that reduces these messages to a single structure that contains information about all resources.", 
            "title": "Atom or Observable?"
        }, 
        {
            "location": "/AtomObservableDiff/#whats-the-difference-between-atom-and-observable-classes", 
            "text": "Both  Atom  and  Observable  look very similar at first glance,\nbut they really have very different purpose.  Atom  is encapsulated observable state value.  Observable  is encapsulated stream of messages, \nthat is: values that are relevant only at time of their publishing.  Let's have this as an example:  import {Atom, Observable} from  immview \n\nconst a$ = new Atom('-')\na$.next('first')\na$.next('second')\na$.subscribe(v =  console.log(`A  ${v}`))\n    // logs: A  second\na$.subscribe(v =  console.log(`A2 ${v}`))\n    // logs: A2 second\na$.next('third')\n    // logs: A  third\n    // logs: A2 third\n\nconst o$ = new Observable(({next}) =  {next('-')})\no$.next('first')\no$.next('second')\no$.subscribe(v =  console.log(`O  ${v}`))\n    // logs: O  -\n    // logs: O  first\n    // logs: O  second\no$.subscribe(v =  console.log(`O2 ${v}`))\no$.next('third')\n    // logs: O  third\n    // logs: O2 third\n\nlog.join('\\n')   see that running live on https://runkit.com/arturkulig/immview-atom-observable-difference   As you can see first few values pushed through the  a$ (Atom)   are lost .\nThis is because these previous values are not that  Atom 's state anymore. It will allow reading it's value to every subscriber and will notify these subscribers if state changes, but it is not a message queue, so previous states are not relevant.  Observable  on the other hand is just  a message queue . No message is lost and all queued messages are dispatched to subscribers as soon as possible. You can make sure that all subscriptions are created by the time first value is pushed, so all of them are notified of all messages, but that is up to a library user, it might not be important after all.", 
            "title": "What's the difference between Atom and Observable classes?"
        }, 
        {
            "location": "/AtomObservableDiff/#where-to-use-which", 
            "text": "Different nature of both of these streaming primitives may be still unclear? More real-life example might be of use.  Consider connectivity through HTTP tooling prepared with  Immview . In case you want to broadcast structures that inform about fetching status of different resources you'd use an  Observable , but if you wish to maintain a registry of requesting and finally - content of  every requested remote resource - you'd prefer an  Atom  for the job.  You might as well have both! First an  Observable  that just broadcasts requests status and then an  Atom  (might be even in different  Domain ) that reduces these messages to a single structure that contains information about all resources.", 
            "title": "Where to use which?"
        }, 
        {
            "location": "/Combine/", 
            "text": "class Combine\nT\n extends \nAtom\nT\n\n\nnew ({ [name: string]: Observable|Atom|Domain })\n\n\nResponsible for being reactive to more than one source and placing source streams contents in their respective (according to informations provided upon initialization) field in result object.\n\n\nnew Combine({\n    a: new Atom('a'),\n    b: new Atom('b'),\n    c: new Observable(observer =\n { observer.next('c') })\n})\n    .subscribe(v =\n {\n        console.log(v)\n            // { a: 'a', b: 'b', c: null }\n            // { a: 'a', b: 'b', c: 'c' }\n    })", 
            "title": "Combine"
        }, 
        {
            "location": "/Combine/#class-combinet-extends-atomt", 
            "text": "new ({ [name: string]: Observable|Atom|Domain })  Responsible for being reactive to more than one source and placing source streams contents in their respective (according to informations provided upon initialization) field in result object.  new Combine({\n    a: new Atom('a'),\n    b: new Atom('b'),\n    c: new Observable(observer =  { observer.next('c') })\n})\n    .subscribe(v =  {\n        console.log(v)\n            // { a: 'a', b: 'b', c: null }\n            // { a: 'a', b: 'b', c: 'c' }\n    })", 
            "title": "class Combine&lt;T&gt; extends Atom&lt;T&gt;"
        }, 
        {
            "location": "/Domain/", 
            "text": "class Domain\nT\n\n\nnew ( source: Observable\nT\n )\n\n\nClass constructor alone will be only helpful when extending \nDomain\n class.\n\n\nYou can create a \nDomain\n either through class inheritance or with factory function \nDomain.create\n.\n\n\nDomain\n have operator functions on prototype\nthat are present both in \nObservable\n and \nAtom\n\nand calling them will actually call operators on stream object\nthat the \nDomain\n has been provided with.\n\n\n\n\nnew Domain through inheritance\n\n\nimport {Combine, Domain, action} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = (() =\n {\n    class EyesDomain extends Domain {\n        constructor() {\n            super(\n                new Combine({\n                    horizon: HorizonDomain,\n                    muscles: MusclesDomain,\n                })\n            )\n        }\n\n        @action\n        async roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    }\n    return new EyesDomain()\n})()\n\n\n\n\n\n\nDomain.create\nT\n\n\n(source: Observable\nT\n | Atom\nT\n, actions: { [name: string]: () =\n promise\nlt;any\ngt; | void }, fields?: {}) =\n Domain\n\n\nDomain\n class by design is the only thing that should be exported and used (maybe with an exception of type definitions) outside of \nDomain\ns scope.\n\n\nFor example, if you have a folder like...\n\n\n\u2514 SomeDomain\n  \u251c index.js // just export\n  \u251c SomeDomain.js // here is Domain creation\n  \u251c SomeDomainState.js // downstream - source observables or stream transformations\n  \u2514 SomeDomainActions.js // functions to manipulate `Domain`'s state\n\n\n\n\n...or just...\n\n\n\u2514 SomeDomain.js // everything\n\n\n\n\n...you should export SomeDomain from index.js and use only that in any other JavaScript module.\n\n\nFirst argument of the factory function is an observable emiting messages that will be emited by the \nDomain\n's instance too.\nOnly single data source can be tied to a \nDomain\n, but you can always use \nCombine\n to combine multiple streams.\n\n\nSecond argument is an object aggregating functions used to create actions and other values that will be exposed as part of the \nDomain\n interface.\nProvided functions will be wrapped with an internal Dispatcher calls. That mechanism ensures that they will always be executed one \nafter\n another. That is a design decision which makes it easier to reason about what is happening inside application.\nFunctions provided as \nDomain\n \nactions\n must not return any value.\nCalling an action however will return a Promise resolved after action function execution.\n\n\n// example usage\nimport {Combine, Domain} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = Domain.create(\n    new Combine({\n        horizon: HorizonDomain,\n        muscles: MusclesDomain,\n    }),\n    {\n        async roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    }\n)\n\nEyesDomain.roll().then(() =\n { console.log('I saw that!') })\n\n\n\n\n\n\nDomainInstance\n.[ACTION_NAME]\n\n\n(...args): Promise\n\n\nA function that was in a provided in constructor set of actions.\nIt is \nnot\n exactly the same function as provided, because it is wrapped with internal scheduler call.\nBecause it's deferred execution \nit always returns a Promise\n resolved with that function result.\n\n\nconst domain = Domain.create(\n    new Observable(observer =\n { ... }),\n    { foo: () =\n console.log('bar') }\n)\ndomain.foo()\n// prints: 'bar'", 
            "title": "Domain"
        }, 
        {
            "location": "/Domain/#class-domaint", 
            "text": "new ( source: Observable T  )  Class constructor alone will be only helpful when extending  Domain  class.  You can create a  Domain  either through class inheritance or with factory function  Domain.create .  Domain  have operator functions on prototype\nthat are present both in  Observable  and  Atom \nand calling them will actually call operators on stream object\nthat the  Domain  has been provided with.", 
            "title": "class Domain&lt;T&gt;"
        }, 
        {
            "location": "/Domain/#new-domain-through-inheritance", 
            "text": "import {Combine, Domain, action} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = (() =  {\n    class EyesDomain extends Domain {\n        constructor() {\n            super(\n                new Combine({\n                    horizon: HorizonDomain,\n                    muscles: MusclesDomain,\n                })\n            )\n        }\n\n        @action\n        async roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    }\n    return new EyesDomain()\n})()", 
            "title": "new Domain through inheritance"
        }, 
        {
            "location": "/Domain/#domaincreatet", 
            "text": "(source: Observable T  | Atom T , actions: { [name: string]: () =  promise lt;any gt; | void }, fields?: {}) =  Domain  Domain  class by design is the only thing that should be exported and used (maybe with an exception of type definitions) outside of  Domain s scope.  For example, if you have a folder like...  \u2514 SomeDomain\n  \u251c index.js // just export\n  \u251c SomeDomain.js // here is Domain creation\n  \u251c SomeDomainState.js // downstream - source observables or stream transformations\n  \u2514 SomeDomainActions.js // functions to manipulate `Domain`'s state  ...or just...  \u2514 SomeDomain.js // everything  ...you should export SomeDomain from index.js and use only that in any other JavaScript module.  First argument of the factory function is an observable emiting messages that will be emited by the  Domain 's instance too.\nOnly single data source can be tied to a  Domain , but you can always use  Combine  to combine multiple streams.  Second argument is an object aggregating functions used to create actions and other values that will be exposed as part of the  Domain  interface.\nProvided functions will be wrapped with an internal Dispatcher calls. That mechanism ensures that they will always be executed one  after  another. That is a design decision which makes it easier to reason about what is happening inside application.\nFunctions provided as  Domain   actions  must not return any value.\nCalling an action however will return a Promise resolved after action function execution.  // example usage\nimport {Combine, Domain} from 'immview'\nimport {HorizonDomain} from './HorizonDomain'\nimport {MusclesDomain} from './MusclesDomain'\n\nconst EyesDomain = Domain.create(\n    new Combine({\n        horizon: HorizonDomain,\n        muscles: MusclesDomain,\n    }),\n    {\n        async roll() {\n            MusclesDomain.doMuscleStuff()\n        }\n    }\n)\n\nEyesDomain.roll().then(() =  { console.log('I saw that!') })", 
            "title": "Domain.create&lt;T&gt;"
        }, 
        {
            "location": "/Domain/#domaininstanceaction_name", 
            "text": "(...args): Promise  A function that was in a provided in constructor set of actions.\nIt is  not  exactly the same function as provided, because it is wrapped with internal scheduler call.\nBecause it's deferred execution  it always returns a Promise  resolved with that function result.  const domain = Domain.create(\n    new Observable(observer =  { ... }),\n    { foo: () =  console.log('bar') }\n)\ndomain.foo()\n// prints: 'bar'", 
            "title": "DomainInstance.[ACTION_NAME]"
        }
    ]
}